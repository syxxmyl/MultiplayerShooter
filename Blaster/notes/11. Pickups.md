# Pickup Class

## 制作一个可拾取物品类

### 创建`Pickup`类处理拾取逻辑

继承自Actor



```cpp
public:
	virtual void Destroyed() override;

protected:
	UFUNCTION()
	virtual void OnSphereBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);

private:
	UPROPERTY(EditAnywhere)
	USphereComponent* OverlapSphere;

	UPROPERTY(EditAnywhere)
	USoundCue* PickupSound;

	UPROPERTY(EditAnywhere)
	UStaticMeshComponent* PickupMesh;
```



用`USceneComponent`可以在蓝图里拖动根结点的位置，不用挨个拖`OverlapSphere`

`OverlapSphere`只对Pawn的Overlap事件有反应

只在server端处理Overlap事件

```cpp
#include "Kismet/GameplayStatics.h"
#include "Sound/SoundCue.h"
#include "Components/SphereComponent.h"


APickup::APickup()
{
	PrimaryActorTick.bCanEverTick = true;
	bReplicates = true;
    
    RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("Root"));
    OverlapSphere = CreateDefaultSubobject<USphereComponent>(TEXT("OverlapSphere"));
    OverlapSphere->SetupAttachment(RootComponent);
    OverlapSphere->SetSphereRadius(150.0f);
    OverlapSphere->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
    OverlapSphere->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);
    OverlapSphere->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Overlap);
    
    PickupMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("PickupMesh"));
    PickupMesh->SetupAttachment(OverlapSphere);
    PickupMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);
}

void APickup::BeginPlay()
{
	Super::BeginPlay();
	
    if(HasAuthority())
    {
        OverlapSphere->OnComponentBeginOverlap.AddDynamic(this, &ThisClass::OnSphereBeginOverlap);
    }
}

void APickup::OnSphereBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
    
}

void APickup::Destroyed()
{
    Super::Destroyed();
    
    if(PickupSound)
    {
        UGameplayStatics::PlaySoundAtLocation(
            this, 
            PickupSound, 
            GetActorLocation()
        );
    }
}
```





### 制作`BP_Pickup`

`PickupMesh`里打开`Render CustomDepth Pass`，`CustomDepth Stencil Value`用250，这样会有个后处理紫色在mesh上







# Ammo Pickups

## 处理拾取弹药



### 在`CombatComponent`处理弹药更新

```cpp
public:
	void PickupAmmo(EWeaponType WeaponType, int32 AmmoAmount);

private:
	UPROPERTY(EditAnywhere)
	int32 MaxCarriedAmmo = 500;
```



```cpp
void UCombatComponent::PickupAmmo(EWeaponType WeaponType, int32 AmmoAmount)
{
    if (CarriedAmmoMap.Contains(WeaponType))
	{
		CarriedAmmoMap[WeaponType] = FMath::Clamp(CarriedAmmoMap[WeaponType] + AmmoAmount, 0, MaxCarriedAmmo);
        
        UpdateCarriedAmmo();
	}
    
    if(EquippedWeapon && EquippedWeapon->IsEmpty() && EquippedWeapon->GetWeaponType() == WeaponType)
    {
        AutoReload();
    }
}
```



### 在`Pickup`里给`StaticMesh`加一个自旋转,`OverlapSphere`的Z轴偏移,`PickupMesh`放缩,启用自定义深度后处理描边

```cpp
protected:
	UPROPERTY(EditAnywhere)
	float BaseTurnRate = 45.0f;
```



```cpp
#include "Blaster/Weapon/WeaponTypes.h"

APickup::APickup()
{
    // ...
    OverlapSphere->AddLocalOffset(FVector(0.0f, 0.0f, 85.0f));
    
    // ...
    PickupMesh->SetRelativeScale3D(FVector(5.0f, 5.0f, 5.0f));
    PickupMesh->SetRenderCustomDepth(true);
    PickupMesh->SetCustomDepthStencilValue(CUSTOM_DEPTH_PURPLE);
}

void APickup::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

    if(PickupMesh)
    {
        PickupMesh->AddWorldRotation(FRotator(0.0f, BaseTurnRate * DeltaTime, 0.0f));
    }
}
```



### 创建拾取弹药类`AmmoPickup`

继承自`Pickup`



```cpp
#include "Blaster/Weapon/WeaponTypes.h"

protected:
	virtual void OnSphereBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);

private:
	UPROPERTY(EditAnywhere)
    int32 AmmoAmount = 30;

	UPROPERTY(EditAnywhere)
    EWeaponType WeaponType;
```



```cpp
#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/BlasterComponents/CombatComponent.h"

void AAmmoPickup::OnSphereBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
    Super::OnSphereBeginOverlap(OverlappedComponent, OtherActor,  OtherComp, OtherBodyIndex, bFromSweep, SweepResult);
    
    ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(OtherActor);
    if(!BlasterCharacter)
    {
        return;
    }
    
    UCombatComponent* Combat = BlasterCharacter->GetCombat();
    if(!Combat)
    {
        return;
    }
    
    Combat->PickupAmmo(WeaponType, AmmoAmount);
    Destroy();
}
```





### 制作突击步枪弹药的蓝图`BP_ARAmmo`

派生自`AmmoPickup`

`StaticMesh`用`AssaultRifle_Pickup`

`Pickup Sound` 用`Rifle_AmmoPickup_Cue`

`AmmoAmount`改成和武器弹夹一致的30

`WeaponType`改成`Assault Rifle`



### 制作手枪弹药的蓝图`BP_PistolAmmo`

派生自`AmmoPickup`

`StaticMesh`用`Pistol_Pickup`

`PickupMesh`沿x轴旋转60度和突击步枪弹药有所区分

`Pickup Sound` 用`Pistol_AmmoPickup_Cue`

`AmmoAmount`改成24

`WeaponType`改成`Pistol`



### 制作冲锋枪弹药的蓝图`BP_SMGAmmo

派生自`AmmoPickup`

`StaticMesh`用`SM_SMG11_Mag_X`

再在蓝图里添加一个`StaticMesh2`用`SM_SMG11_Mag_X`并旋转形成一个X的形状，`StaticMesh2`也要打开`CustomDepth`

`Pickup Sound` 找一个合适的

`AmmoAmount`改成35

`WeaponType`改成`SubmachineGun`



### 制作霰弹枪弹药的蓝图`BP_ShotgunAmmo`

派生自`AmmoPickup`

`StaticMesh`用`Shotgun_Pickup`

`Pickup Sound` 用`Shotgun_AmmoPickup_Cue`

`AmmoAmount`改成5

`WeaponType`改成`Shotgun`



### 制作火箭弹弹药的蓝图`BP_RocketAmmo`

派生自`AmmoPickup`

`StaticMesh`用`RocketLauncheer_Pickup`

`Pickup Sound` 用`RocketLauncher_AmmoPickup_Cue`

`AmmoAmount`改成4

`WeaponType`改成`RocketLauncher`



### 制作狙击弹药的蓝图`BP_SniperAmmo`

派生自`AmmoPickup`

`StaticMesh`用`SniperRifle_Pickup`

`Pickup Sound` 用`SniperRifle_AmmoPickup_Cue`

`AmmoAmount`改成6

`WeaponType`改成`SniperRifle`



### 制作榴弹弹药的蓝图`BP_GrenadeLauncherAmmo`

派生自`AmmoPickup`

`StaticMesh`用`GrenadeLauncher_Pickup`

`Pickup Sound` 用`GrenadeLauncher_AmmoPickup_Cue`

`AmmoAmount`改成8

`WeaponType`改成`GrenadeLauncher`





# Buff Component

## 新增buff组件

### 创建`BuffComponent`

继承自`ActorComponent`



```cpp
public:	
	friend class ABlasterCharacter;

private:
	UPROPERTY()
	ABlasterCharacter* Character;
```



### 在`BlasterCharacter`里添加Buff组件

```cpp
private:
	UPROPERTY(VisibleAnywhere)
	UBuffComponent* Buff;
```



```cpp
#include "Blaster/BlasterComponents/BuffComponent.h"

ABlasterCharacter::ABlasterCharacter()
{
    // ...
    Buff = CreateDefaultSubobject<UBuffComponent>(TEXT("Buff"));
	Buff->SetIsReplicated(true);
}

void ABlasterCharacter::PostInitializeComponents()
{
	// ...
    
	if (Buff)
	{
		Buff->Character = this;
	}
}
```







# Health Pickup

## 生命恢复拾取

assets用epic商店里的免费素材`Basic Pickups VFX Set`



### 修改Asset不再自行控制生命周期而是由代码控制

`NS_Pickup_3`选择`NE_PickupCricle`、`NE_Aura`和`NE_PickupCricle001`的`PARTICLE UPDATE`取消勾选`Kill Particles When Lifetime Has Elapsed`



### 创建新的生命恢复拾取类`HealthPickup`

继承自`Pickup`



在若干秒内总计恢复若干生命值

```cpp
public:
	AHealthPickup();
	virtual void Destroyed() override;

protected:
	virtual void OnSphereBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult) override;

private:
	UPROPERTY(EditAnywhere)
    float HealAmount = 100.0f;

	UPROPERTY(EditAnywhere)
	float HealingTime = 5.0f;

	UPROPERTY(VisibleAnywhere)
	UNiagaraComponent* PickupEffectComponent;

	UPROPERTY(EditAnywhere)
	UNiagaraSystem* PickupEffect;
```



```cpp
#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/BlasterComponents/BuffComponent.h"
#include "NiagaraFunctionLibrary.h"
#include "NiagaraComponent.h"

AHealthPickup::AHealthPickup()
{
	bReplicates = true;
    
    PickupEffectComponent = CreateDefaultSubobject<UNiagaraComponent>(TEXT("PickupEffectComponent"));
    PickupEffectComponent->SetupAttachment(RootComponent);
}

void AHealthPickup::OnSphereBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	Super::OnSphereBeginOverlap(OverlappedComponent, OtherActor, OtherComp, OtherBodyIndex, bFromSweep, SweepResult);

	ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(OtherActor);
	if (!BlasterCharacter)
	{
		return;
	}
    
    Destroy();
}

void AHealthPickup::Destroyed()
{   
    if(PickupEffect)
    {
        UNiagaraFunctionLibrary::SpawnSystemAtLocation(
        	this,
            PickupEffect,
            GetActorLocation(),
            GetActorRotation()
        );
    }
    
    Super::Destroyed();
}
```



### 制作`BP_HealthPickup`

派生自`HealthPickup`

`NiagaraSystemAsset`用`NS_Pickup_3`

`PickupEffect`用`NS_Healing_1`

`PickupSound`用`HealthPickup_Cue`





# Healing the Character

## 发生Overlap时正确通过BuffComponent恢复玩家生命值



### 在`BlasterCharacter`里把`BuffComponent`暴露出来以及设置Health

`UpdateHUDHealth`从protected挪到public里用来给`BuffComponent`用

```cpp
public:
	FORCEINLINE UBuffComponent* GetBuff() const { return Buff; }
	FORCEINLINE void SetHealth(float Amount){ Health = Amount; }
	void UpdateHUDHealth();

private:
	UFUNCTION()
	void OnRep_Health(float LastHealth);
```



```cpp
void ABlasterCharacter::OnRep_Health(float LastHealth)
{
	UpdateHUDHealth();
    if(Health < LastHealth)
    {
        PlayHitReactMontage();
    }
}
```



### 在`BuffComponent`里治疗玩家

```cpp
public:
	void Heal(float HealAmount, float HealingTime);

protected:
	void HealRampUp(float DeltaTime);

private:
	bool bHealing = false;
	float HealingRate = 0.0f;
	float AmountToHeal = 0.0f;
```



```cpp
#include "Blaster/Character/BlasterCharacter.h"

void UBuffComponent::Heal(float HealAmount, float HealingTime)
{
    bHealing = true;
    AmountToHeal += HealAmount;
    HealingRate = HealAmount / HealingTime;
}

void UBuffComponent::HealRampUp(float DeltaTime)
{
    if(!bHealing || !Character || Character->IsElimmed())
    {
        return;
    }

    const float HealThisFrame = HealingRate * DeltaTime;
    Character->SetHealth(FMath::Clamp(Character->GetHealth() + HealThisFrame, 0.0f, Character->GetMaxHealth()));
    Character->UpdateHUDHealth();
    AmountToHeal -= HealThisFrame;
    
    if(AmountToHeal <= 0.0f || Character->GetHealth() >= Character->GetMaxHealth())
    {
        bHealing = false;
        AmountToHeal = 0.0f;
    }
}

void UBuffComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

    HealRampUp(DeltaTime);
}
```



### 在`HealthPickup`里处理

```cpp
void AHealthPickup::OnSphereBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	Super::OnSphereBeginOverlap(OverlappedComponent, OtherActor, OtherComp, OtherBodyIndex, bFromSweep, SweepResult);

	ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(OtherActor);
	if (!BlasterCharacter)
	{
		return;
	}

    UBuffComponent* Buff = BlasterCharacter->GetBuff();
    if(!Buff)
    {
        return;
    }
    
    Buff->Heal(HealAmount, HealingTime);
    
	Destroy();
}
```





## 把NiagaraComponent挪到Pickup基类里

构造函数初始化的

```cpp
PickupEffectComponent = CreateDefaultSubobject<UNiagaraComponent>(TEXT("PickupEffectComponent"));
PickupEffectComponent->SetupAttachment(RootComponent);
```



销毁时播放特效

```cpp
if (PickupEffect)
{
    UNiagaraFunctionLibrary::SpawnSystemAtLocation(
        this,
        PickupEffect,
        GetActorLocation(),
        GetActorRotation()
    );
}
```



# Speed Buffs

## 制作新的移速Buff



### 在`BlasterCharacter`里给`BuffComponent`的基础移速赋值

```cpp
void ABlasterCharacter::PostInitializeComponents()
{
	// ...

	if (Buff)
	{
		Buff->Character = this;
        Buff->SetInitialSpeeds(GetCharacterMovement()->MaxWalkSpeed, GetCharacterMovement()->MaxWalkSpeedCrouched);
	}
}
```



### 在`BuffComponent`里处理移速buff

```cpp
public:
	void BuffSpeed(float BuffBaseSpeed, float BuffCrouchSpeed, float BuffTime);

	void SetInitialSpeeds(float BaseSpeed, float CrouchSpeed);

private:
	FTimerHandle SpeedBuffTimer;
	void ResetSpeeds();
	float InitialBaseSpeed;
	float InitialCrouchSpeed;

	UFUNCTION(NetMulticast, Reliable)
    void MulticastSpeedBuff(float BaseSpeed, float CrouchSpeed);
```



```cpp
#include "GameFramework/CharacterMovementComponent.h"

void UBuffComponent::SetInitialSpeeds(float BaseSpeed, float CrouchSpeed)
{
    InitialBaseSpeed = BaseSpeed;
    InitialCrouchSpeed = CrouchSpeed;
}

void UBuffComponent::MulticastSpeedBuff_Implementation(float BaseSpeed, float CrouchSpeed)
{
    if(!Character || !Character->GetCharacterMovement())
    {
        return;
    }
    
    Character->GetCharacterMovement()->MaxWalkSpeed = BaseSpeed;
    Character->GetCharacterMovement()->MaxWalkSpeedCrouched = CrouchSpeed;
}

void UBuffComponent::BuffSpeed(float BuffBaseSpeed, float BuffCrouchSpeed, float BuffTime)
{
    if(!Character)
    {
        return;
    }
    
    Character->GetWorldTimerManager().SetTimer(
    	SpeedBuffTimer,
        this,
        &ThisClass::ResetSpeeds,
        BuffTime
    );
    
    MulticastSpeedBuff(BuffBaseSpeed, BuffCrouchSpeed);
}

void UBuffComponent::ResetSpeeds()
{
    MulticastSpeedBuff(InitialBaseSpeed, InitialCrouchSpeed);
}
```



### 创建新的`SpeedPickup`类

继承自`Pickup`



```cpp
protected:
	virtual void OnSphereBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult) override;

private:
	UPROPERTY(EditAnywhere)
    float BaseSpeedBuff = 1600.0f;

	UPROPERTY(EditAnywhere)
    float CrouchSpeedBuff = 850.0f;

	UPROPERTY(EditAnywhere)
    float SpeedBuffTime = 30.0f;
```



```cpp
#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/BlasterComponents/BuffComponent.h"

void ASpeedPickup::OnSphereBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	Super::OnSphereBeginOverlap(OverlappedComponent, OtherActor, OtherComp, OtherBodyIndex, bFromSweep, SweepResult);

	ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(OtherActor);
	if (!BlasterCharacter)
	{
		return;
	}

	UBuffComponent* Buff = BlasterCharacter->GetBuff();
	if (!Buff)
	{
		return;
	}

	Buff->BuffSpeed(BaseSpeedBuff, CrouchSpeedBuff, SpeedBuffTime);

	Destroy();
}
```



### 修改要用的Asset

#### `NS_Pickup_2`

`NE_PickupCricle`、`NE_Aura`和`NE_PickupCricle001`的`PARTICLE UPDATE`取消勾选`Kill Particles When Lifetime Has Elapsed`



#### `NS_Energy_2`

`PARTICLE SPAWN`的`LifeTime`改成3.0f，`SPRITE ATTRIBUTES`的`Sprite Size Value B`改成15.0，`MESH ATTRIBUTES`的`Mesh Scale Value`改成(0.2,0.6)，

`ADD VELOCITY IN CONE`的`Velocity Strength`改成2.0

`SPAWN RATE`的`Spawn Rate`改成35

`SPHERE LOCATION`的`Sphere Radius`改成65.0

`EMITTER UPDATE`里，因为他的`Life Cycle Mode`不是`System`而是`Self`，这意味着这个`Emitter`由自己控制生命周期而不是这个`Niagara System`，为了保持原Asset的一致，所以把`Loop Behavior`改成`Once`，`Loop Duration Mode`改成`Fixed`，`Loop Duration`改成2.0f

`NS_Energy_2`的`Loop Behavior`改成`Once`



### 制作新的`BP_SpeedPickup`

派生自`SpeedPickup`

`NiagaraSystemAsset`用`NS_Pickup_2`

`PickupEffect`用`NS_Energy_2`

`PickupSound`用`Special_Musical_04_wav_Cue`





# Jump Buffs

## 增加一个跳跃Buff

### 找个跳跃的Asset

Epic商店里的`Interface & Item Sounds Pack`



### 在`BlasterCharacter`里给`BuffComponent`的基础移速赋值

```cpp
void ABlasterCharacter::PostInitializeComponents()
{
	// ...

	if (Buff)
	{
		// ...
        Buff->SetInitialJumpVelocity(GetCharacterMovement()->JumpZVelocity);
	}
}
```



### 在`BuffComponent`里处理跳跃buff

```cpp
public:
	void BuffJump(float BuffJumpVelocity, float BuffTime);

	void SetInitialJumpVelocity(float Velocity);

private:
	FTimerHandle JumpBuffTimer;
	void ResetJump();
	float InitialJumpVelocity;

	UFUNCTION(NetMulticast, Reliable)
    void MulticastJumpBuff(float JumpVelocity);
```



```cpp
void UBuffComponent::SetInitialJumpVelocity(float Velocity)
{
    InitialJumpVelocity = Velocity;
}

void UBuffComponent::BuffJump(float BuffJumpVelocity, float BuffTime)
{
    if(!Character)
    {
        return;
    }
    
    Character->GetWorldTimerManager().SetTimer(
    	JumpBuffTimer,
        this,
        &ThisClass::ResetJump,
        BuffTime
    );
    
    MulticastJumpBuff(BuffJumpVelocity);
}

void UBuffComponent::ResetJump()
{
    MulticastJumpBuff(InitialJumpVelocity);
}

void UBuffComponent::MulticastJumpBuff_Implementation(float JumpVelocity)
{
    if(!Character || !Character->GetCharacterMovement())
    {
        return;
    }
    
    Character->GetCharacterMovement()->JumpZVelocity = JumpVelocity;
}
```



### 添加`JumpPickup`类

继承自`Pickup`



```cpp
protected:
	virtual void OnSphereBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult) override;

private:
	UPROPERTY(EditAnywhere)
    float JumpZVelocityBuff = 4000.0f;

	UPROPERTY(EditAnywhere)
    float JumpBuffTime = 30.0f;
```



```cpp
#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/BlasterComponents/BuffComponent.h"

void AJumpPickup::OnSphereBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	Super::OnSphereBeginOverlap(OverlappedComponent, OtherActor, OtherComp, OtherBodyIndex, bFromSweep, SweepResult);

	ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(OtherActor);
	if (!BlasterCharacter)
	{
		return;
	}

	UBuffComponent* Buff = BlasterCharacter->GetBuff();
	if (!Buff)
	{
		return;
	}

	Buff->BuffJump(JumpZVelocityBuff, JumpBuffTime);

	Destroy();
}
```



### 修改要用的Asset

#### `NS_Pickup_5`

`NE_PickupCricle`、`NE_Aura`和`NE_PickupCricle001`的`PARTICLE UPDATE`取消勾选`Kill Particles When Lifetime Has Elapsed`



#### `NS_Magic_1`

取消勾选`NE_PickupCricle001`

`NE_Aura`的`EMITTER UPDATE`里修改`Inactive Response`改成`Kill`

`NE_PickupCricle`的`EMITTER UPDATE`里修改`Loop Duration Mode`改成`Fixed`，`Loop Duration` 改成2.0

`NS_Magic_1`的`Loop Behavior`改成`Once`





### 制作`BP_JumpPickup`

派生自`JumpPickup`

`NiagaraSystemAsset`用`NS_Pickup_5`

`PickupEffect`用`NS_Magic_1`

`PickupSound`用`Special_Powerup_08_wav_Cue`





# Shield Bar

## 给玩家加个护盾值的概念

### 在`WBP_CharacterOverlay`添加护盾值控件

拖一个`Progress Bar` 命名为 `ShieldBar`放在生命值下方，RGB改成(0,0,1)

拖一个`Text Block` 命名为 `ShieldText`



### 在`CharacterOverlay`添加护盾相关的变量

```cpp
priavte:
	UPROPERTY(meta = (BindWidget))
	UProgressBar* ShieldBar;

	UPROPERTY(meta = (BindWidget))
	UTextBlock* ShieldText;
```



### 在`BlasterPlayerController`处理更新护盾值HUD

```cpp
public:
	void SetHUDShield(float Shield, float MaxShield);

private:
	float HUDShield;
	float HUDMaxShield;
```



```cpp
void ABlasterPlayerController::PollInit()
{
    if (CharacterOverlay)
    {
        SetHUDShield(HUDShield, HUDMaxShield);
    	// ...
    }
}

void ABlasterPlayerController::SetHUDShield(float Shield, float MaxShield)
{
    BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;
	bool bHUDValid = MaxShield != 0.0f &&
		BlasterHUD &&
		BlasterHUD->CharacterOverlay &&
		BlasterHUD->CharacterOverlay->ShieldBar &&
		BlasterHUD->CharacterOverlay->ShieldText;

	if (bHUDValid)
	{
		const float ShieldPercent = Shield / MaxShield;
		BlasterHUD->CharacterOverlay->ShieldBar->SetPercent(ShieldPercent);
		FString ShieldText = FString::Printf(TEXT("%d/%d"), FMath::CeilToInt(Shield), FMath::CeilToInt(MaxShield));
		BlasterHUD->CharacterOverlay->ShieldText->SetText(FText::FromString(ShieldText));
	}
	else
	{
		bInitializeCharacterOverlay = true;
		HUDShield = Shield;
		HUDMaxShield = MaxShield;
	}
}
```



### 在`BlasterCharacter`里添加护盾值变量

```cpp
public:
	void UpdateHUDShield();

private:
	UPROPERTY(EditAnywhere, Category = "Player Stats")
	float MaxShield = 100.0f;

	UPROPERTY(ReplicatedUsing = OnRep_Shield, VisibleAnywhere, Category = "Player Stats")
	float Shield = 100.0f;

	UFUNCTION()
	void OnRep_Shield(float LastShield);
```



```cpp
void ABlasterCharacter::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	// ...
	DOREPLIFETIME(ABlasterCharacter, Shield);
}

void ABlasterCharacter::UpdateHUDShield()
{
	BlasterPlayerController = BlasterPlayerController == nullptr ? Cast<ABlasterPlayerController>(Controller) : BlasterPlayerController;
	if (BlasterPlayerController)
	{
		BlasterPlayerController->SetHUDShield(Shield, MaxShield);
	}
}

void ABlasterCharacter::OnRep_Shield(float LastShield)
{
	UpdateHUDShield();
    if(Shield < LastShield)
    {
        PlayHitReactMontage();
    }
}
```





# Updating the Shield

## 更新护盾值

### 在`BlasterCharacter`里更新护盾值



```cpp
void ABlasterCharacter::BeginPlay()
{
	// ...
	UpdateHUDShield();
}

void ABlasterCharacter::ReceiveDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatorController, AActor* DamageCauser)
{
    float DamageToHealth = ReceiveDamageToShield(Damage);    
    Health = FMath::Clamp(Health - DamageToHealth, 0.0f, MaxHealth);
    // ...
}

float ABlasterCharacter::ReceiveDamageToShield(float Damage)
{
	float DamageToHealth = Damage;
	if (Shield > 0.0f && Damage > 0.0f)
	{
		if (Shield >= Damage)
		{
			Shield = FMath::Clamp(Shield - Damage, 0.0f, MaxShield);
			DamageToHealth = 0.0f;
		}
		else
		{
			Shield = 0.0f;
			DamageToHealth = FMath::Clamp(DamageToHealth - Shield, 0.0f, Damage);
		}

		UpdateHUDShield();
	}
}
```



### 在`BlasterPlayerController`里处理`PollInit`覆盖了原本的值的问题

```cpp
private:
	bool bInitializeHealth = false;
	bool bInitializeScore = false;
	bool bInitializeDefeats = false;
	bool bInitializeGrenades = false;
	bool bInitializeShield = false;
```



```cpp
void ABlasterPlayerController::PollInit()
{
    if (CharacterOverlay)
    {
        if(bInitializeXXX)
        {
            SetHUDXXX();
        }
    }
}

void ABlasterPlayerController::SetHUDHealth(float Health, float MaxHealth)
void ABlasterPlayerController::SetHUDScore(float Score)
void ABlasterPlayerController::SetHUDDefeats(int32 Defeats)
void ABlasterPlayerController::SetHUDGrenades(int32 Grenades)
void ABlasterPlayerController::SetHUDShield(float Shield, float MaxShield)
{
    // ...
    else
    {
        bInitializeXXX = true;
    }
}


{
    
}
```







# Shield Buffs

## 制作护盾Buff



### 在`BlasterCharacter`里把`Shield`暴露出来

`Shield`改成`EditAnywhere`

```cpp
public:
	FORCEINLINE float GetShield() const { return Shield; }
	FORCEINLINE float GetMaxShield() const { return MaxShield; }
	FORCEINLINE void SetShield(float Amount){ Shield = Amount; }

private:
	UPROPERTY(ReplicatedUsing = OnRep_Shield, EditAnywhere, Category = "Player Stats")
	float Shield = 100.0f;
```





### 在`BuffComponent`里治疗玩家

```cpp
public:
	void ReplenishShield(float ShieldAmount, float ReplenishTime);

protected:
	void ShieldRampUp(float DeltaTime);

private:
	bool bReplenishingShield = false;
	float ShieldReplenishRate = 0.0f;
	float ShieldReplenishAmount = 0.0f;
```



```cpp
#include "Blaster/Character/BlasterCharacter.h"

void UBuffComponent::ReplenishShield(float ShieldAmount, float ReplenishTime)
{
    bReplenishingShield = true;
    ShieldReplenishAmount += ShieldAmount;
    ShieldReplenishRate = ShieldAmount / ReplenishTime;
}

void UBuffComponent::ShieldRampUp(float DeltaTime)
{
    if(!bReplenishingShield || !Character || Character->IsElimmed())
    {
        return;
    }

    const float ReplenishThisFrame = ShieldReplenishRate * DeltaTime;
    Character->SetShield(FMath::Clamp(Character->GetShield() + ReplenishThisFrame, 0.0f, Character->GetMaxShield()));
    Character->UpdateHUDShield();
    ShieldReplenishAmount -= ReplenishThisFrame;
    
    if(ShieldReplenishAmount <= 0.0f || Character->GetShield() >= Character->GetMaxShield())
    {
        bReplenishingShield = false;
        ShieldReplenishAmount = 0.0f;
    }
}

void UBuffComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

    HealRampUp(DeltaTime);
    ShieldRampUp(DeltaTime);
}
```



### 创建新的`ShieldPickup`类

继承自`Pickup`



```cpp
protected:
	virtual void OnSphereBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult) override;

private:
	UPROPERTY(EditAnywhere)
    float ShieldReplenishAmount = 100.0f;

	UPROPERTY(EditAnywhere)
    float ShieldReplenishTime = 5.0f;
```



```cpp
#include "Blaster/Character/BlasterCharacter.h"
#include "Blaster/BlasterComponents/BuffComponent.h"

void AShieldPickup::OnSphereBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	Super::OnSphereBeginOverlap(OverlappedComponent, OtherActor, OtherComp, OtherBodyIndex, bFromSweep, SweepResult);

	ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(OtherActor);
	if (!BlasterCharacter)
	{
		return;
	}

	UBuffComponent* Buff = BlasterCharacter->GetBuff();
	if (!Buff)
	{
		return;
	}

	Buff->ReplenishShield(ShieldReplenishAmount, ShieldReplenishTime);

	Destroy();
}
```



### 修改要用的Asset

#### `NS_Pickup_4`

`NE_PickupCricle`、`NE_Aura`和`NE_PickupCricle001`的`PARTICLE UPDATE`取消勾选`Kill Particles When Lifetime Has Elapsed`



### 制作`BP_ShieldPickup`

派生自`ShieldPickup`

`NiagaraSystemAsset`用`NS_Pickup_4`

`PickupSound`用`ShieldBuff_Cue`





# Pickup Spawn Point

## 定时生成随机的可拾取Actor

### 创建新的`PickupSpawnPoint`类



```cpp
protected:
	UPROPERTY(EditAnywhere)
    TArray<TSubclassOf<APickup>> PickupClasses;

	void SpawnPickup();

	void SpawnPickupTimerFinished();

	UFUNCTION()
	void StartSpawnPickupTimer(AActor* DestroyedActor);

	UPROPERTY()
	APickup* SpawnedPickup;

private:
	FTimerHandle SpawnPickupTimer;

	UPROPERTY(EditAnywhere)
    float SpawnPickupTimeMin;

	UPROPERTY(EditAnywhere)
    float SpawnPickupTimeMax;
```



```cpp
#include "Pickup.h"

APickupSpawnPoint::APickupSpawnPoint()
{
    // ...
	bReplicates = true;
}

void APickupSpawnPoint::BeginPlay()
{
	// ...
	StartSpawnPickupTimer((AActor*)nullptr);
}

void APickupSpawnPoint::SpawnPickup()
{
    int32 NumPickupClasses = PickupClasses.Num();
    if(NumPickupClasses == 0)
    {
        return;
    }
    
    int32 Selection = FMath::RandRange(0, NumPickupClasses - 1);
    SpawnedPickup = GetWorld()->SpawnActor<APickup>(PickupClasses[Selection], GetActorTransform());
    
    if(HasAuthority() && SpawnedPickup)
    {
        SpawnedPickup->OnDestroyed.AddDynamic(this, &ThisClass::StartSpawnPickupTimer);
    }
}

void APickupSpawnPoint::SpawnPickupTimerFinished()
{
    if(HasAuthority())
    {
        SpawnPickup();
    }
}

void APickupSpawnPoint::StartSpawnPickupTimer(AActor* DestroyedActor)
{
    const float SpawnTime = FMath::RandRange(SpawnPickupTimeMin, SpawnPickupTimeMax);
    GetWorldTimerManager().SetTimer(
    	SpawnPickupTimer,
        this,
        &ThisClass::SpawnPickupTimerFinished,
        SpawnTime
    );
}
```



### 延迟`Pickup`的绑定Overlap

加个定时器延迟绑定Overlap事件，以防止刚创建的时候玩家就和他发生了Overlap导致立刻Destroy，而SpawnPickup里的`OnDestroyed`的绑定还没来得及绑定上

```cpp
private:
	FTimerHandle BindOverlapTimer;

	UPROPERTY(EditAnywhere)
	float BindOverlapTime = 0.25f;

	void BindOverlapTimerFinished();
```



```cpp
void APickup::BeginPlay()
{
    // ...
    if(HasAuthority())
    {
        GetWorldTimerManager().SetTimer(
        	BindOverlapTimer,
            this,
            &ThisClass::BindOverlapTimerFinished,
            BindOverlapTime
        );
    }
}

void APickup::BindOverlapTimerFinished()
{
    if (HasAuthority())
	{
		OverlapSphere->OnComponentBeginOverlap.AddDynamic(this, &ThisClass::OnSphereBeginOverlap);
	}
}
```



### 制作`BP_BuffSpawnPoint`

`PickupClasses`把buff都加上

`SpawnPickupTimeMin`填1，`SpawnPickupTimeMax`填5



### 制作`BP_AmmoSpawnPoint`

`PickupClasses`把ammo都加上，也可以做一个只Spawn某种特定类型ammo的蓝图，Array只加一种Ammo





# Spawn Default Weapon

## 玩家出生的时候自带一把默认武器



### 在`Weapon`里加个变量标记是否需要销毁

```cpp
public:
	bool bDestroyWeapon = false;
```



### 在`CombatComponent`里处理默认武器和销毁

```cpp
private:
	UPROPERTY(EditAnywhere)
    TSubclassOf<AWeapon> DefaultWeaponClass;
```



`DropWeapon`会在`ABlasterCharacter::Elim`里调用，当玩家被淘汰的时候把默认武器销毁掉

```cpp
void UCombatComponent::DropWeapon()
{
	if (!EquippedWeapon)
	{
		return;
	}

	EquippedWeapon->Dropped();
	if (EquippedWeapon->bDestroyWeapon)
	{
		EquippedWeapon->Destroy();
	}
	
	EquippedWeapon = nullptr;
}
```



### 在`BlasterCharacter`里处理默认武器的生成

只在`BlasterGameMode`的时候带默认武器

```cpp
public:
	void SpawnDefaultWeapon();

protected:
	void UpdateHUDAmmo();
```



```cpp
void ABlasterCharacter::BeginPlay()
{
    // ...
    SpawnDefaultWeapon();
    UpdateHUDAmmo();
}

void ABlasterCharacter::SpawnDefaultWeapon()
{
    ABlasterGameMode* BlasterGameMode = Cast<ABlasterGameMode>(UGameplayStatics::GetGameMode(this));
    UWorld* World = GetWorld();
    if(BlasterGameMode && World && !bElimmed &&  && Combat && Combat->DefaultWeaponClass)
    {
        AWeapon* StartingWeapon = World->SpawnActor<AWeapon>(Combat->DefaultWeaponClass);
        if(StartingWeapon && Combat)
        {
            StartingWeapon->bDestroyWeapon = true;
            Combat->EquipWeapon(StartingWeapon);
        }
    }
}

void ABlasterCharacter::UpdateHUDAmmo()
{
    BlasterPlayerController = BlasterPlayerController == nullptr ? Cast<ABlasterPlayerController>(Controller) : BlasterPlayerController;
	if (BlasterPlayerController && Combat && Combat->EquippedWeapon)
	{
		BlasterPlayerController->SetHUDCarriedAmmo(Combat->CarriedAmmo);
        BlasterPlayerController->SetHUDWeaponAmmo(Combat->EquippedWeapon->GetAmmo());
	}
	else
	{
        bUpdateHUDCarriedAmmo = true;
		bUpdateHUDWeaponAmmo = true;
	}
}
```



### 在`BlasterPlayerController`里处理`SetHUDAmmo`失败的情况

```cpp
private:
	int32 HUDCarriedAmmo;
	bool bInitializeCarriedAmmo = false;

	int32 HUDWeaponAmmo;
	bool bInitializeWeaponAmmo = false;
```



```cpp
void ABlasterPlayerController::PollInit()
{
    // ...
    if (bInitializeCarriedAmmo)
    {
        SetHUDCarriedAmmo(HUDCarriedAmmo);
    }
    
    if (bInitializeWeaponAmmo)
    {
        SetHUDWeaponAmmo(HUDWeaponAmmo);
    }
}

void ABlasterPlayerController::SetHUDWeaponAmmo(int32 Ammo)
{
    // ...
    else
    {
        HUDWeaponAmmo = Ammo;
        bInitializeWeaponAmmo = true;
    }
}

void ABlasterPlayerController::SetHUDCarriedAmmo(int32 Ammo)
{
    // ...
    else
    {
        HUDCarriedAmmo = Ammo;
        bInitializeCarriedAmmo = true;
    }
}
```





# Secondary Weapon

## 玩家可以装备两把武器并把第二把武器挂在背包上



### 在`SK_EpicCharacter_Skeleton`里添加第二把武器要挂载的具体socket位置

在`backpack`添加`socket`命名为`BackpackSocket`，把它移动到背包表面，添加preview asset修改socket的朝向使武器在合适的位置



### 在`CombatComponent`里处理第二把武器的逻辑

`PlayEquipWeaponSound`改一下，加个入参播放入参的装备音效

把`EquipWeapon`里的逻辑分成`EquipPrimaryWeapon`和`EquipSecondaryWeapon`两部分

副武器在背包上的时候换一种后处理渲染深度颜色

`DropWeapon`被淘汰的时候记得把副武器也丢地上

```cpp
protected:
	UFUNCTION()
	void OnRep_SecondaryWeapon();

	void EquipPrimaryWeapon(AWeapon* WeaponToEquip);
	void EquipSecondaryWeapon(AWeapon* WeaponToEquip);

	void AttachActorToBackpack(AActor* ActorToAttach);

	void PlayEquipWeaponSound(AWeapon* WeaponToEquip);

private:
	UPROPERTY(ReplicatedUsing = OnRep_SecondaryWeapon)
	AWeapon* SecondaryWeapon;
```



```cpp
void UCombatComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	// ...
	DOREPLIFETIME(UCombatComponent, SecondaryWeapon);
}

void UCombatComponent::AttachActorToBackpack(AActor* ActorToAttach)
{
	if (!Character || !Character->GetMesh() || !ActorToAttach)
	{
		return;
	}

	const USkeletalMeshSocket* BackpackSocket = Character->GetMesh()->GetSocketByName(FName("BackpackSocket"));
	if (BackpackSocket)
	{
		BackpackSocket->AttachActor(ActorToAttach, Character->GetMesh());
	}
}

void UCombatComponent::EquipPrimaryWeapon(AWeapon* WeaponToEquip)
{
    if(!WeaponToEquip)
    {
        return;
    }
    
    DropEquippedWeapon();

	EquippedWeapon = WeaponToEquip;
	EquippedWeapon->SetWeaponState(EWeaponState::EWS_Equipped);
	EquippedWeapon->SetOwner(Character);
	EquippedWeapon->SetHUDAmmo();

	UpdateCarriedAmmo();
	AttachActorToRightHand(EquippedWeapon);

	PlayEquipWeaponSound(WeaponToEquip);
	AutoReload();
    
    EquippedWeapon->EnableCustomDepth(false);
}

void UCombatComponent::EquipSecondaryWeapon(AWeapon* WeaponToEquip)
{
    if(!WeaponToEquip)
    {
        return;
    }
    
    SecondaryWeapon = WeaponToEquip;
    SecondaryWeapon->SetWeaponState(EWeaponState::EWS_Equipped);
    SecondaryWeapon->SetOwner(Character);
    
    AttachActorToBackpack(WeaponToEquip);
    
    PlayEquipWeaponSound(WeaponToEquip);
    
    if(SecondaryWeapon->GetWeaponMesh())
    {
        SecondaryWeapon->GetWeaponMesh()->SetCustomDepthStencilValue(CUSTOM_DEPTH_TAN);
		SecondaryWeapon->GetWeaponMesh()->MarkRenderStateDirty();
    }
}

void UCombatComponent::EquipWeapon(AWeapon* WeaponToEquip)
{
	if (!Character || !WeaponToEquip)
	{
		return;
	}
	
	if (CombatState != ECombatState::ECS_Unoccupied)
	{
		return;
	}
    
    if(EquippedWeapon && !SecondaryWeapon)
    {
        EquipSecondaryWeapon(WeaponToEquip);
    }
    else
    {
        EquipPrimaryWeapon(WeaponToEquip);
    }

    Character->bUseControllerRotationYaw = true;
	Character->GetCharacterMovement()->bOrientRotationToMovement = false;
}

void UCombatComponent::PlayEquipWeaponSound(AWeapon* WeaponToEquip)
{
	if (!Character || !WeaponToEquip)
	{
		return;
	}

	if (WeaponToEquip->EquipSound)
	{
		UGameplayStatics::PlaySoundAtLocation(
			this,
			WeaponToEquip->EquipSound,
			Character->GetActorLocation()
		);
	}
}

void UCombatComponent::OnRep_EquippedWeapon()
{
    // ...
    PlayEquipWeaponSound(EquippedWeapon);
    EquippedWeapon->EnableCustomDepth(false);
}

void UCombatComponent::OnRep_SecondaryWeapon()
{
    if (Character && SecondaryWeapon)
	{
		SecondaryWeapon->SetWeaponState(EWeaponState::EWS_Equipped);
		AttachActorToBackpack(SecondaryWeapon);
		PlayEquipWeaponSound(SecondaryWeapon);
        if(SecondaryWeapon->GetWeaponMesh())
        {
            SecondaryWeapon->GetWeaponMesh()->SetCustomDepthStencilValue(CUSTOM_DEPTH_TAN);
			SecondaryWeapon->GetWeaponMesh()->MarkRenderStateDirty();
        }
        
	}
}

void UCombatComponent::DropWeapon()
{
	if (EquippedWeapon)
	{
		EquippedWeapon->Dropped();
		if (EquippedWeapon->bDestroyWeapon)
		{
			EquippedWeapon->Destroy();
		}

		EquippedWeapon = nullptr;
	}

	if (SecondaryWeapon)
	{
		SecondaryWeapon->Dropped();
		if (SecondaryWeapon->bDestroyWeapon)
		{
			SecondaryWeapon->Destroy();
		}

		SecondaryWeapon = nullptr;
	}
}
```



### 把原本在`Weapon`里处理武器的后处理渲染是否使用自定义深度挪到`CombatComponent`里 以及同步Owner的时候刷新HUD要检查下是哪把武器，只刷新主武器

```cpp
void AWeapon::SetWeaponState(EWeaponState State)
{
    // ...
    // EnableCustomDepth(false);
}

void AWeapon::OnRep_WeaponState()
{
    // ...
    // EnableCustomDepth(false);
}

void AWeapon::OnRep_Owner()
{
	// ...
	else
	{
        BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(Owner) : BlasterOwnerCharacter;
        if(BlasterOwnerCharacter && BlasterOwnerCharacter->GetEquippedWeapon() && BlasterOwnerCharacter->GetEquippedWeapon() == this)
        {
            SetHUDAmmo();
        }
	}
}
```





# Swap Weapons

## 交换手中和背包上挂着的武器



### 在`Weapon`里添加新的武器状态并重构武器状态切换函数

参考`GameMode`里的`OnMatchStateSet`

```cpp
UENUM(BlueprintType)
enum class EWeaponState : uint8
{
	EWS_Initial UMETA(DisplayName = "Initial State"),
	EWS_Equipped UMETA(DisplayName = "Equipped"),
    EWS_EquippedSecondary UMETA(DisplayName = "Equipped Secondary"),
	EWS_Dropped UMETA(DisplayName = "Dropped"),
	EWS_MAX UMETA(DisplayName = "DefaultMAX"),
};


protected:
	virtual void OnWeaponStateSet();
	virtual void OnEquipped();
	virtual void OnEquippedSecondary();
	virtual void OnDropped();
```



```cpp
void AWeapon::OnEquipped()
{
    ShowPickupWidget(false);
    AreaSphere->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    WeaponMesh->SetSimulatePhysics(false);
    WeaponMesh->SetEnableGravity(false);
    WeaponMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    if (WeaponType == EWeaponType::EWT_SubmachineGun)
    {
        WeaponMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
        WeaponMesh->SetEnableGravity(true);
        WeaponMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);
    }
    
    EnableCustomDepth(false);
}

void AWeapon::OnEquippedSecondary()
{
    ShowPickupWidget(false);
    AreaSphere->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    WeaponMesh->SetSimulatePhysics(false);
    WeaponMesh->SetEnableGravity(false);
    WeaponMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    if (WeaponType == EWeaponType::EWT_SubmachineGun)
    {
        WeaponMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
        WeaponMesh->SetEnableGravity(true);
        WeaponMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);
    }
    
    EnableCustomDepth(true);
    if(WeaponMesh)
    {
        WeaponMesh->SetCustomDepthStencilValue(CUSTOM_DEPTH_TAN);
    	WeaponMesh->MarkRenderStateDirty();
    }
}

void AWeapon::OnDropped()
{
    if (HasAuthority())
    {
        AreaSphere->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
    }
    WeaponMesh->SetSimulatePhysics(true);
    WeaponMesh->SetEnableGravity(true);
    WeaponMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
    WeaponMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);
    WeaponMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Ignore);
    WeaponMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_Camera, ECollisionResponse::ECR_Ignore);
    WeaponMesh->SetCustomDepthStencilValue(CUSTOM_DEPTH_BLUE);
    WeaponMesh->MarkRenderStateDirty();
    EnableCustomDepth(true);
}

void AWeapon::OnWeaponStateSet()
{
	switch (WeaponState)
	{
	case EWeaponState::EWS_Equipped:
	{
		OnEquipped();
		break;
	}
    case EWeaponState::EWS_EquippedSecondary:
	{
		OnEquippedSecondary();
		break;
	}
	case EWeaponState::EWS_Dropped:
	{
		OnDropped();
		break;
	}
	default:
		break;
	}
}

void AWeapon::SetWeaponState(EWeaponState State)
{
    WeaponState = State;
    OnWeaponStateSet();
}

void AWeapon::OnRep_WeaponState()
{
    OnWeaponStateSet();
}
```



### 更新`CombatComponent`里的`EquipSecondaryWeapon`

更换后处理自定义深度颜色的内容也挪回到`Weapon`里新的`WeaponState`处理函数里

```cpp
public:
	void SwapWeapons();
	bool ShouldSwapWeapons();
```



需要注意的是SwapWeapon的时候`EquippedWeapon->SetHUDAmmo();`和`UpdateCarriedAmmo();`而`UpdateCarriedAmmo`里修改的`CarriedAmmo`是网络同步的，所以对于`AmmoHUD`客户端要走`OnRep_EquippedWeapon`来更新HUD，不过之前改刷新HUD的时候已经做了

```cpp
void UCombatComponent::EquipSecondaryWeapon(AWeapon* WeaponToEquip)
{
    // ...
    SecondaryWeapon->SetWeaponState(EWeaponState::EWS_EquippedSecondary);
    
    /*
    EquippedWeapon->EnableCustomDepth(false);
    */
}

void UCombatComponent::OnRep_SecondaryWeapon()
{
    // ...
    SecondaryWeapon->SetWeaponState(EWeaponState::EWS_EquippedSecondary);
    
    /*
    if (SecondaryWeapon->GetWeaponMesh())
    {
        SecondaryWeapon->GetWeaponMesh()->SetCustomDepthStencilValue(CUSTOM_DEPTH_TAN);
        SecondaryWeapon->GetWeaponMesh()->MarkRenderStateDirty();
    }
    */
}

void UCombatComponent::SwapWeapons()
{
    AWeapon* TempWeapon = EquippedWeapon;
    EquippedWeapon = SecondaryWeapon;
    SecondaryWeapon = TempWeapon;
    
    EquippedWeapon->SetWeaponState(EWeaponState::EWS_Equipped);
    EquippedWeapon->SetHUDAmmo();
	AttachActorToRightHand(EquippedWeapon);
	UpdateCarriedAmmo();
    PlayEquipWeaponSound(EquippedWeapon);
    
    SecondaryWeapon->SetWeaponState(EWeaponState::EWS_EquippedSecondary);
	AttachActorToBackpack(SecondaryWeapon);
    
	AutoReload();
}

bool UCombatComponent::ShouldSwapWeapons()
{
    return (EquippedWeapon && SecondaryWeapon && CombatState == ECombatState::ECS_Unoccupied);
}

void UCombatComponent::OnRep_EquippedWeapon()
{
    // ...
    if (Character)
	{
		Character->UpdateHUDWeaponAmmo();
		Character->UpdateHUDCarriedAmmo();
	}
}
```



### 在`BlasterCharacter`里判断装备武器的按键是拾取武器还是切换武器



```cpp
void ABlasterCharacter::EquipButtonPressed()
{
	if (bDisableGameplay)
	{
		return;
	}

	if (Combat)
	{
		if (HasAuthority())
		{
            if(OverlappingWeapon)
            {
                Combat->EquipWeapon(OverlappingWeapon);
            }
			else if(Combat->ShouldSwapWeapons())
            {
                Combat->SwapWeapons();
            }
		}
		else
		{
			ServerEquipButtonPressed();
		}
	}
}
```







# Drop the Secondary Weapon

## 当玩家被淘汰时应当把副武器Drop掉

之前在`UCombatComponent::DropWeapon`里做过了













