# Lag Compensation Concepts

## Ping

```
Packet Internet or Inter-Network Groper
```

fps游戏如果ping大于50ms就很容易被察觉到，为了让玩家的体验更好引入了下面的滞后补偿



## Lag Compensation

### Client-Side Prediction

客户端预测

#### 角色移动

容易由于服务端的权威位置和客户端本地位置有偏差而导致角色抖动，需要单独处理

#### 开枪

一般有两种处理方式，客户端只播放枪口动画、枪声等视觉表现效果，子弹Actor由服务端创建并下发给客户端，因此会感觉到从开枪到子弹出现有延迟

另一种情况是客户端不但播放枪口动画、枪声等视觉表现效果，也产生一个子弹Actor并产生碰撞事件，只是客户端不计算伤害，服务端收到客户端开枪的请求后产生子弹Actor但是不会同步给客户端，而是在服务端计算完伤害后直接同步伤害结果给客户端



#### Interpolation

插值

可以减轻玩家的滞后感

比如玩家移动时客户端根据当前帧和上一帧的位置在其中增加插值，可以让移动看起来更平滑，但是玩家的实时位置要落后于服务端



#### Extrapolation

推断

客户端根据角色的运动情况，比如某个角色一段时间内都在像某方向移动，那么客户端可以在收到下一帧位置更新前先把角色像该方向进行移动，但是不适用于频繁修改移动方向的情景



#### CharacterMovementComponent

使用`Interpolation`和`Extrapolation`结合的方法来优化客户端的移动体验，优先使用`Extrapolation`移动客户端角色，如果有偏差则用`Interpolation`逐渐回正，如果偏差值较大则会直接用`Rubber-banding`来`Teleport`玩家



### Server-Side Rewind

服务端侧倒带	主要侧重于改善高ping玩家的游戏体验

服务端将玩家的移动轨迹存储下来，客户端请求同步的时候附上时间戳，服务端把对应时间戳的移动位置从存储的移动轨迹中找出来，用这个位置来判断子弹是否命中、射线追踪等内容，然后把结果返回给客户端

对被击中的玩家游戏体验不太好，他们可能已经跑进掩体了但是在服务端的那一时刻人还在掩体外所以被击杀了

```cpp
Client Scores a Hit->
Client Tell the Server->
Server Rewinds Time->
Checks for Valid Hit
```







# High Ping Warning

## ping值过高的时候在HUD提示一下

### 在`WBP_CharacterOverlay`里添加图标

添加一个`Image`命名为`HighPingImage`，`Image`用`Wifi_Signal`，`Render Opacity`设置为0

给这个Image加个动画命名为`HighPingAnimation`，`Add Track`选择`Render Opacity`，在1秒的时候把值设置为0，然后点击`Loop playback range`可以预览





### 在`CharacterOverlay`里绑定

`Transient`代表这个变量没有被序列化到磁盘，可以在运行时修改

```cpp
private:
	UPROPERTY(meta = (BindWidget))
	UImage* HighPingImage;

	UPROPERTY(meta = (BindWidgetAnim), Transient)
	UWidgetAnimation* HighPingAnimation;
```





### 在`BlasterPlayerController`里处理显示

每间隔`CheckPingFrequency`检查一次Ping值，如果太高了则显示`HighPingDuration`秒

`PlayerState->GetCompressedPing()`返回的是一个代表真实`Ping`的1/4的被压缩过的`int8`，，它的准确性没有那么高所以之前计算延迟的时候没用这个，但是显示高ping警告不需要那么高的精确度所以可以用它

```cpp
protected:
	void HighPingWarning();
	void StopHighPingWarning();
	void CheckPing(float DeltaTime);

private:
	float HighPingRunningTime = 0.0f;
	float PingAnimationRunningTime = 0.0f;

	UPROPERTY(EditAnywhere)
	float HighPingDuration = 5.0f;

	UPROPERTY(EditAnywhere)
	float CheckPingFrequency = 20.0f;

	UPROPERTY(EditAnywhere)
	float HighPingThreshold = 50.0f;
```



```cpp
#include "Components/Image.h"

void ABlasterPlayerController::Tick(float DeltaTime)
{
	// ...
    CheckPing(DeltaTime);
}

void ABlasterPlayerController::CheckPing(float DeltaTime)
{
    HighPingRunningTime += DeltaTime;
    if(HighPingRunningTime >= CheckPingFrequency)
    {
        PlayerState = PlayerState == nullptr ? GetPlayerState<APlayerState>() : PlayerState;
        if(PlayerState)
        {
            if(HighPingThreshold < PlayerState->GetCompressedPing() * 4)
            {
                HighPingWarning();
                PingAnimationRunningTime = 0.0f;
            }
        }
        HighPingRunningTime = 0.0f;
    }
    
    bool bHighPingAnimationPlaying = BlasterHUD && 
        BlasterHUD->CharacterOverlay && 
        BlasterHUD->CharacterOverlay->HighPingAnimation && 
        BlasterHUD->CharacterOverlay->IsAnimationPlaying(BlasterHUD->CharacterOverlay->HighPingAnimation);
    
    if(bHighPingAnimationPlaying)
    {
        PingAnimationRunningTime += DeltaTime;
    }
    
    if(PingAnimationRunningTime > HighPingDuration)
    {
        StopHighPingWarning();
    }
}

void ABlasterPlayerController::HighPingWarning()
{
    BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;
	bool bHUDValid = BlasterHUD &&
		BlasterHUD->CharacterOverlay &&
		BlasterHUD->CharacterOverlay->HighPingImage &&
		BlasterHUD->CharacterOverlay->HighPingAnimation;

	if (bHUDValid)
	{
		BlasterHUD->CharacterOverlay->HighPingImage->SetOpacity(1.0f);
        BlasterHUD->CharacterOverlay->PlayAnimation(
            BlasterHUD->CharacterOverlay->HighPingAnimation,
        	0.0f,
            5
        );
	}
}

void ABlasterPlayerController::StopHighPingWarning()
{
    BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;
	bool bHUDValid = BlasterHUD &&
		BlasterHUD->CharacterOverlay &&
		BlasterHUD->CharacterOverlay->HighPingImage &&
		BlasterHUD->CharacterOverlay->HighPingAnimation;

	if (bHUDValid)
	{
		BlasterHUD->CharacterOverlay->HighPingImage->SetOpacity(0.0f);
        
        if(BlasterHUD->CharacterOverlay->IsAnimationPlaying(BlasterHUD->CharacterOverlay->HighPingAnimation))
        {
            BlasterHUD->CharacterOverlay->StopAnimation(BlasterHUD->CharacterOverlay->HighPingAnimation);
        }
    }
}
```



### 在编辑器模式PIE下模拟高延迟滞后

打开项目工程的`Config->DefaultEngine.ini`

输入以下内容延迟100毫秒

```ini
[PacketSimulationSettings]
PktLag = 100
```



删除`Binaries`，`Intermediate`和`Saved`以后用`.uproject`重新生成项目文件来应用更改





# Local Fire Effects

## 客户端本地处理开火的各种视觉效果

### 在`CombatComponent`里处理

把`MulticastFire`里的内容挪到`LocalFire`里，当调用`Fire`的时候也在客户端执行一次`LocalFire`播放各种视觉效果如开火动画、音效等，在`MulticastFire`判断下只有不是本地控制的才会执行`LocalFire`，防止客户端播放两次

```cpp
private:
	void LocalFire(const FVector_NetQuantize& TraceHitTarget);
```



```cpp
void UCombatComponent::Fire()
{
	// ...
    if (Character && Character->IsLocallyControlled() && !Character->HasAuthority())
	{
		LocalFire(HitTarget);
	}
}

void UCombatComponent::LocalFire(const FVector_NetQuantize& TraceHitTarget)
{
    if (!EquippedWeapon)
	{
		return;
	}

	if (Character && 
		CombatState == ECombatState::ECS_Reloading && 
		EquippedWeapon->GetWeaponType() == EWeaponType::EWT_Shotgun)
	{
		Character->PlayFireMontage(bIsAiming);
		EquippedWeapon->Fire(TraceHitTarget);
		CombatState = ECombatState::ECS_Unoccupied;
		return;
	}

	if (Character && CombatState == ECombatState::ECS_Unoccupied)
	{
		Character->PlayFireMontage(bIsAiming);
		EquippedWeapon->Fire(TraceHitTarget);
	}
}

void UCombatComponent::MulticastFire_Implementation(const FVector_NetQuantize& TraceHitTarget)
{
    if(Character && Character->IsLocallyControlled() && !Character->HasAuthority())
    {
        return;
    }
    LocalFire(TraceHitTarget);
}
```



### 在`Weapon`里处理

只有Server端才能消耗弹药

```cpp
void AWeapon::Fire(const FVector& HitTarget)
{
	// ...
    if(HasAuthority())
    {
        SpendRound();
    }
}
```







# Show the Widget Locally

## 只在客户端本地显示Pickup的Widget

因为重叠事件现在只在服务端执行，所以客户端会有延迟



### 在`Weapon`里把碰撞检测的权限放开给客户端

```cpp
void AWeapon::BeginPlay()
{
	Super::BeginPlay();

    AreaSphere->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
    AreaSphere->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Overlap);
    AreaSphere->OnComponentBeginOverlap.AddDynamic(this, &AWeapon::OnSphereBeginOverlap);
    AreaSphere->OnComponentEndOverlap.AddDynamic(this, &AWeapon::OnSphereEndOverlap);
    
	/*
    if (HasAuthority())
	{
		
	}
	*/
    
	if (PickupWidget)
	{
		PickupWidget->SetVisibility(false);
	}
}
```







# Replicating Scatter

## 复制`HitScan`类武器的随机散布



### 在`Weapon`里加个新的武器开火类型枚举，把`HitScanWeapon`里的散射相关内容挪过来

`bUseScatter`挪过来，用来标识是否应用散射

`TraceEndWithScatter`改成只要一个`HitTarget`的，`TraceStart`直接从socket里拿

```cpp
UENUM(BlueprintType)
enum class EFireType : uint8
{
	EFT_HitScan UMETA(DisplayName = "Hit Scan Weapon"),
	EFT_Projectile UMETA(DisplayName = "Projectile Weapon"),
    EFT_Shotgun UMETA(DisplayName = "Shotgun Weapon"),
	EFT_MAX UMETA(DisplayName = "DefaultMAX"),
};

public:
	FVector TraceEndWithScatter(const FVector& HitTarget);
	FORCEINLINE EFireType GetFireType() const { return FireType; }
	FORCEINLINE bool GetUseScatter() const { return bUseScatter; }

private:
	UPROPERTY(EditAnywhere)
	EFireType FireType;

	UPROPERTY(EditAnywhere, Category = "Weapon Scatter")
	bool bUseScatter = false;

	UPROPERTY(EditAnywhere, Category = "Weapon Scatter")
	float DistanceToSphere = 800.0f;

	UPROPERTY(EditAnywhere, Category = "Weapon Scatter")
	float SphereRadius = 75.0f;
```



```cpp
#include "Kismet/KismetMathLibrary.h"

FVector AWeapon::TraceEndWithScatter(const FVector& HitTarget)
{
    const USkeletalMeshSocket* MuzzleFlashSocket = GetWeaponMesh()->GetSocketByName("MuzzleFlash");
	if (!MuzzleFlashSocket)
	{
		return FVector();
	}
    
    FTransform SocketTransform = MuzzleFlashSocket->GetSocketTransform(GetWeaponMesh());
	FVector TraceStart = SocketTransform.GetLocation();
    
    // ...
}
```



### `HitScanWeapon`里把计算散布修改一下

```cpp
void AHitScanWeapon::WeaponTraceHit(const FVector& TraceStart, const FVector& HitTarget, FHitResult& OutHit)
{
    // ...
    // FVector End = bUseScatter ? TraceEndWithScatter(TraceStart, HitTarget) : TraceStart + (HitTarget - TraceStart) * 1.25f;
    FVector End = TraceStart + (HitTarget - TraceStart) * 1.25f;
    // ...
}


```



### `CombatComponent`根据武器类型执行不同的开火

```cpp
private:
	void FireProjectileWeapon();
	void FireHitScanWeapon();
	void FireShotgun();
```



```cpp
void UCombatComponent::Fire()
{
	if (!CanFire())
	{
		return;
	}

	bCanFire = false;

	if (EquippedWeapon)
	{
		CrosshairShootingFactor = 0.75f;
        switch(EquippedWeapon->FireType)
        {
            case EFireType::EFT_Projectile:
                {
                    FireProjectileWeapon();
                    break;
                }
            case EFireType::EFT_HitScan:
                {
                    FireHitScanWeapon();
                    break;
                }
            case EFireType::EFT_Shotgun:
                {
                    FireShotgun();
                    break;
                }
        }
	}

	StartFireTimer();
}

void UCombatComponent::FireProjectileWeapon()
{
    if (Character && Character->IsLocallyControlled() && !Character->HasAuthority())
	{
		LocalFire(HitTarget);
	}
    ServerFire(HitTarget);
}

void UCombatComponent::FireHitScanWeapon()
{
    if(!EquippedWeapon)
    {
        return;
    }
    
    HitTarget = EquippedWeapon->bUseScatter ? EquippedWeapon->TraceEndWithScatter(HitTarget) : HitTarget;
    
    if (Character && Character->IsLocallyControlled() && !Character->HasAuthority())
	{
		LocalFire(HitTarget);
	}
    ServerFire(HitTarget);
	
	
}

void UCombatComponent::FireShotgun()
{
    
}
```







# Replicating Shotgun Scatter

## 复制霰弹枪的散布



### 把`Weapon`里的一些变量挪到`protected`

方便派生类`AShotgun`使用

```cpp
protected:
	UPROPERTY(EditAnywhere, Category = "Weapon Scatter")
	float DistanceToSphere = 800.0f;

	UPROPERTY(EditAnywhere, Category = "Weapon Scatter")
	float SphereRadius = 75.0f;
```



### 在`Shotgun`里处理散布

用const修饰变量可以方便的看出哪些变量之后修改了哪些变量没有

```cpp
public:
	void ShotgunTraceEndWithScatter(const FVector& HitTarget, TArray<FVector>& HitTargets);
```



```cpp
#include "Kismet/KismetMathLibrary.h"

void AShotgun::ShotgunTraceEndWithScatter(const FVector& HitTarget, TArray<FVector>& HitTargets)
{
    const USkeletalMeshSocket* MuzzleFlashSocket = GetWeaponMesh()->GetSocketByName("MuzzleFlash");
	if (!MuzzleFlashSocket)
	{
		return;
	}

	const FTransform SocketTransform = MuzzleFlashSocket->GetSocketTransform(GetWeaponMesh());
	const FVector TraceStart = SocketTransform.GetLocation();

	const FVector ToTargetNorlmalized = (HitTarget - TraceStart).GetSafeNormal();
	const FVector SphereCenter = TraceStart + ToTargetNorlmalized * DistanceToSphere;

    for(uint32 i = 0; i < NumberOfPellets; ++i)
    {
        const FVector RandVec = UKismetMathLibrary::RandomUnitVector() * FMath::FRandRange(0.0f, SphereRadius);
        const FVector EndLoc = SphereCenter + RandVec;
        FVector ToEndLoc = EndLoc - TraceStart;
        ToEndLoc = FVector(TraceStart + ToEndLoc * TRACE_LENGTH / ToEndLoc.Size());
        
        HitTargets.Add(ToEndLoc);
    }
}
```



### 在`CombatComponent`里处理同步



```cpp
#include "Blaster/Weapon/Shotgun.h"

void UCombatComponent::FireShotgun()
{
    if(!EquippedWeapon)
    {
        return;
    }
    
    AShotgun* Shotgun = Cast<AShotgun>(EquippedWeapon);
    if(!Shotgun)
    {
        return;
    }
    
	TArray<FVector> HitTargets;
    Shotgun->ShotgunTraceEndWithScatter(HitTarget, HitTargets);
}
```







# Shotgun Fire RPCs

## 加个RPC单独处理多发子弹轨迹的霰弹枪开火



### 修改`Shotgun`的开火

用`FireShotgun`代替`Fire`

把`ShotgunTraceEndWithScatter`的入参改成`TArray<FVector_NetQuantize>&`类型的方便`CombatComponent`调用

```cpp
public:
	virtual void FireShotgun(const TArray<FVector_NetQuantize>& HitTargets);
	void ShotgunTraceEndWithScatter(const FVector& HitTarget, TArray<FVector_NetQuantize>& HitTargets);
```



```cpp
void AShotgun::FireShotgun(const TArray<FVector_NetQuantize>& HitTargets)
{
	AWeapon::Fire(FVector());
    
    // ...

	TMap<ABlasterCharacter*, uint32> HitMap;
	for (FVector_NetQuantize HitTarget : HitTargets)
	{
		FHitResult FireHit;
		WeaponTraceHit(Start, HitTarget, FireHit);

		ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(FireHit.GetActor());
		if (BlasterCharacter)
		{
			// ...
		}
	}

	// ...
}
```



### 在`CombatComponent`里单独处理霰弹枪的开火

```cpp
protected:
	void LocalShotgunFire(const TArray<FVector_NetQuantize>& TraceHitTargets);

	UFUNCTION(Server, Reliable)
    void ServerShotgunFire(const TArray<FVector_NetQuantize>& TraceHitTargets);

	UFUNCTION(NetMulticast, Reliable)
	void MulticastShotgunFire(const TArray<FVector_NetQuantize>& TraceHitTargets);
```



```cpp
void UCombatComponent::FireShotgun()
{
    if(!EquippedWeapon)
    {
        return;
    }
    
    AShotgun* Shotgun = Cast<AShotgun>(EquippedWeapon);
    if(!Shotgun)
    {
        return;
    }
    
	TArray<FVector_NetQuantize> HitTargets;
    Shotgun->ShotgunTraceEndWithScatter(HitTarget, HitTargets);
    
    if (Character && Character->IsLocallyControlled() && !Character->HasAuthority())
    {
        LocalShotgunFire(HitTargets);
    }
    ServerShotgunFire(HitTargets);
}

void UCombatComponent::LocalFire(const FVector_NetQuantize& TraceHitTarget)
{
	if (!EquippedWeapon)
	{
		return;
	}

	if (Character && CombatState == ECombatState::ECS_Unoccupied)
	{
		Character->PlayFireMontage(bIsAiming);
		EquippedWeapon->Fire(TraceHitTarget);
	}
}

void UCombatComponent::LocalShotgunFire(const TArray<FVector_NetQuantize>& TraceHitTargets)
{
    AShotgun* Shotgun = Cast<AShotgun>(EquippedWeapon);
    
    if (!Shotgun || !Character)
	{
		return;
	}

	if (CombatState == ECombatState::ECS_Reloading || CombatState == ECombatState::ECS_Unoccupied)
	{
		Character->PlayFireMontage(bIsAiming);
		Shotgun->FireShotgun(TraceHitTargets);
		CombatState = ECombatState::ECS_Unoccupied;
	}
}

void UCombatComponent::ServerShotgunFire_Implementation(const TArray<FVector_NetQuantize>& TraceHitTargets)
{
    MulticastShotgunFire(TraceHitTargets);
}
    
void UCombatComponent::MulticastShotgunFire_Implementation(const TArray<FVector_NetQuantize>& TraceHitTargets)
{
    if (Character && Character->IsLocallyControlled() && !Character->HasAuthority())
    {
        return;
    }
    
    LocalShotgunFire(TraceHitTargets);
}
```







# Client-Side Prediction

## Reconciliation

以移动为例

客户端本地保存每次移动时调用的RPC的时间戳和位置坐标，

服务端返回RPC的调用结果时把时间戳和服务端认为的位置坐标一并返回，

客户端收到服务端的返回结果后进行比对，

如果两端的位置坐标相同则客户端不用回滚，而是认为在那个时间戳客户端所处的位置坐标是服务端验证了的，否则执行回滚把玩家拉回。

最后客户端继续处理剩余的还没有经过服务端验证的移动操作，执行移动预测移动玩家



```
Client Moves->
Client Send RPC and Save it->
Server process RPC and Send Response to Client->
Client Receives processed Response from Server->
Client Applies correction->
Client Discards old movement that already processed by server->
Client Applies all unprocessed movement
```







# Client-Side Predicting Ammo

## 客户端预测开火时的剩余弹药量

### 在`Weapon`里添加弹药量预测相关

用`UpdateAmmo`和`AddAmmo`的`Client RPC`代替`Ammo`的`Replicate`

用`UnProcessedAmmoSequence`代表服务端还没有处理的子弹消耗数量，因为子弹是 一发一发算的所以可以直接用一个变量来做

`SpendRound`改成客户端服务端都要调用的

```cpp
private:
	UFUNCTION(Client, Reliable)
	void ClientUpdateAmmo(int32 ServerAmmo);

	UFUNCTION(Client, Reliable)
    void ClientAddAmmo(int32 AmmoToAdd);

	int32 UnProcessedAmmoSequence = 0;
```



```cpp
void AWeapon::SpendRound()
{
	Ammo = FMath::Clamp(Ammo - 1, 0, MagCapacity);
	SetHUDAmmo();
    if(HasAuthority())
    {
        ClientUpdateAmmo(Ammo);
    }
    else
    {
        ++UnProcessedAmmoSequence;
    }
}

void AWeapon::ClientUpdateAmmo_Implementation(int32 ServerAmmo)
{
    if(HasAuthority())
    {
        return;
    }
    
    Ammo = ServerAmmo;
    --UnProcessedAmmoSequence;
    Ammo = FMath::Clamp(Ammo - UnProcessedAmmoSequence, 0, MagCapacity);
    SetHUDAmmo();
}

void AWeapon::AddAmmo(int32 AmmoToAdd)
{
	Ammo = FMath::Clamp(Ammo + AmmoToAdd, 0, MagCapacity);
	SetHUDAmmo();
    ClientAddAmmo(AmmoToAdd);
}

void AWeapon::ClientAddAmmo_Implementation(int32 AmmoToAdd)
{
    if(HasAuthority())
    {
        return;
    }
    
    Ammo = FMath::Clamp(Ammo + AmmoToAdd, 0, MagCapacity);
    BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(GetOwner()) : BlasterOwnerCharacter;
	if (BlasterOwnerCharacter && BlasterOwnerCharacter->GetCombat() && IsFull())
	{
		BlasterOwnerCharacter->GetCombat()->JumpToShotgunEnd();
	}
    SetHUDAmmo();
}

void AWeapon::Fire(const FVector& HitTarget)
{
    // ...
    SpendRound();
}
```







# Client-Side Predicting Aiming

## 在客户端预测瞄准

如果快速的按一下瞄准紧接着就释放，客户端本身会处理一次缩放，而当高延迟的情况下服务端把`bIsAiming`的变化同步给客户端会导致再一次缩放，即按一次瞄准会缩放两次

即客户端本地快速缩放，会发送true和false各一次，同时`AnimInstance`会播放一轮动画，当服务端收到客户端的两次变换并回传给客户端的时候客户端本地的`AnimInstance`又会播放一轮动画

### 在`CombatComponent`处理瞄准的客户端预测

本地Character的`bIsAiming`由存在本地的变量控制

```cpp
private:
	UPROPERTY(ReplicatedUsing = OnRep_Aiming)
	bool bIsAiming = false;

	bool bAimButtonPressed = false;

	UFUNCTION()
	void OnRep_Aiming();
```



```cpp
void UCombatComponent::SetAiming(bool bAiming)
{
    // ...
    if(Character->IsLocallyControlled())
    {
        bAimButtonPressed = bAiming;
    }
}

void UCombatComponent::OnRep_Aiming()
{
    if(Character && Character->IsLocallyControlled())
    {
        bIsAiming = bAimButtonPressed;
    }
}
```







# Client-Side Predicting Reloading

## 用客户端预测优化高延迟下的换弹动画

### 在`CombatComponent`里处理

```cpp
public:
	FORCEINLINE bool GetLocallyReloading() const { return bLocallyReloading; }
        
private:
	bool bLocallyReloading = false;
```



```cpp
void UCombatComponent::Reload()
{
	if (CarriedAmmo > 0 && CombatState == ECombatState::ECS_Unoccupied && EquippedWeapon && !EquippedWeapon->IsFull() && !bLocallyReloading)
	{
		ServerReload();
        HandleReload();
        bLocallyReloading = true;
	}
}

void UCombatComponent::FinishReloading()
{
    // ...
    bLocallyReloading = false;
}

bool UCombatComponent::CanFire()
{
	if(bLocallyReloading)
    {
        return false;
    }
    
    // ...
}

void UCombatComponent::ServerReload_Implementation()
{
	if (Character)
	{
		CombatState = ECombatState::ECS_Reloading;
		if(!Character->IsLocallyControlled())
        {
            HandleReload();
        }
	}
}

void UCombatComponent::HandleReload()
{
    if(Character)
    {
        Character->PlayReloadMontage();
    }
}

void UCombatComponent::OnRep_CombatState()
{
    case ECombatState::ECS_Reloading:
	{
		if(Character && !Character->IsLocallyControlled())
        {
            HandleReload();
        }
		break;
	}
}
```



### 在`BlasterCharacter`把Combat的`bLocallyReloading`暴露给AnimInstance

```cpp
public:
	bool IsLocallyReloading();
```



```cpp
bool ABlasterCharacter::IsLocallyReloading()
{
    if(!Combat)
    {
        return false;
    }
    
    return Combat->GetLocallyReloading();
}
```



### 在`BlasterAnimInstance`用`bLocallyReloading`切换是否使用`FABRIK`

覆盖要保证原逻辑投掷手榴弹的分支也要被正确处理

```cpp
void UBlasterAnimInstance::NativeUpdateAnimation(float DeltaTime)
{
	// ...
    bUseFABRIK = BlasterCharacter->GetCombatState() == ECombatState::ECS_Unoccupied;
    if(BlasterCharacter->IsLocallyControlled() && BlasterCharacter->GetCombatState() != ECombatState::ECS_ThrowingGrenade)
    {
        bUseFABRIK = !BlasterCharacter->IsLocallyReloading();
    }
}
```







# Server-Side Rewind

客户端看到的其他客户端都是从服务端网络同步复制下来的，具有滞后性

`Server-Side Rewind`意味着服务端要保存角色在每个时间戳的位置作为数据快照，客户端调用RPC的时候附带执行这个RPC的时间戳，服务端根据该时间戳结合客户端到服务端的延时来找到对应的数据快照来计算相应的事件

这种方式更偏向于高ping玩家，对低延迟的玩家非常不友好，所以要考虑何时使用`Server-Side Rewind`







# Lag Compensation Component

## 制作滞后补偿组件

### Recording History

应当存储哪些数据

如果只存储坐标，那么如果客户端瞄准头部，而对方蹲下了，只凭借位置坐标是无法判断命中的

可以考虑存储玩家的碰撞胶囊体，但是玩家的Mesh和Skeleton不是完全贴合胶囊体的

不考虑存储玩家的每块骨骼的位置坐标，因为这样内存存储的成本太高了

最终选择存储玩家的`BoxComponent`，同时满足较高的准确性和较少的存储空间消耗



### 创建新的`LagCompensationComponent`类

继承自`ActorComponent`







# Hit Boxes

## 给角色加一个`HitBox`

### 在`BlasterCharacter`里处理

添加和`SK_EpicCharacter_Skeleton`里骨骼对应的`BoxComponent`，

包括头部、骨盆、脊椎、上臂、下臂、手、背包、大腿、小腿、脚

```cpp
public:
	UPROPERTY(EditAnywhere)
	UBoxComponent* head;

	UPROPERTY(EditAnywhere)
	UBoxComponent* pelvis;

	UPROPERTY(EditAnywhere)
	UBoxComponent* spine_02;

	UPROPERTY(EditAnywhere)
	UBoxComponent* spine_03;

	UPROPERTY(EditAnywhere)
	UBoxComponent* upperarm_l;

	UPROPERTY(EditAnywhere)
	UBoxComponent* upperarm_r;

	UPROPERTY(EditAnywhere)
	UBoxComponent* lowerarm_l;

	UPROPERTY(EditAnywhere)
	UBoxComponent* lowerarm_r;

	UPROPERTY(EditAnywhere)
	UBoxComponent* hand_l;

	UPROPERTY(EditAnywhere)
	UBoxComponent* hand_r;

	UPROPERTY(EditAnywhere)
	UBoxComponent* backpack;

	UPROPERTY(EditAnywhere)
	UBoxComponent* blanket;

	UPROPERTY(EditAnywhere)
	UBoxComponent* thigh_l;

	UPROPERTY(EditAnywhere)
	UBoxComponent* thigh_r;

	UPROPERTY(EditAnywhere)
	UBoxComponent* calf_l;

	UPROPERTY(EditAnywhere)
	UBoxComponent* calf_r;

	UPROPERTY(EditAnywhere)
	UBoxComponent* foot_l;

	UPROPERTY(EditAnywhere)
	UBoxComponent* foot_r;
```



```cpp
#include "Components/BoxComponent.h"

ABlasterCharacter::ABlasterCharacter()
{
    // ...
    head = CreateDefaultSubobject<UBoxComponent>(TEXT("head"));
	head->SetupAttachment(GetMesh(), FName("head"));
    head->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    pelvis = CreateDefaultSubobject<UBoxComponent>(TEXT("pelvis"));
	pelvis->SetupAttachment(GetMesh(), FName("pelvis"));
    pelvis->SetCollisionEnabled(ECollisionEnabled::NoCollision);  
    
    spine_02 = CreateDefaultSubobject<UBoxComponent>(TEXT("spine_02"));
	spine_02->SetupAttachment(GetMesh(), FName("spine_02"));
    spine_02->SetCollisionEnabled(ECollisionEnabled::NoCollision);  
    
    spine_03 = CreateDefaultSubobject<UBoxComponent>(TEXT("spine_03"));
	spine_03->SetupAttachment(GetMesh(), FName("spine_03"));
    spine_03->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    upperarm_l = CreateDefaultSubobject<UBoxComponent>(TEXT("upperarm_l"));
	upperarm_l->SetupAttachment(GetMesh(), FName("upperarm_l"));
    upperarm_l->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    upperarm_r = CreateDefaultSubobject<UBoxComponent>(TEXT("upperarm_r"));
	upperarm_r->SetupAttachment(GetMesh(), FName("upperarm_r"));
    upperarm_r->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    lowerarm_l = CreateDefaultSubobject<UBoxComponent>(TEXT("lowerarm_l"));
	lowerarm_l->SetupAttachment(GetMesh(), FName("lowerarm_l"));
    lowerarm_l->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    lowerarm_r = CreateDefaultSubobject<UBoxComponent>(TEXT("lowerarm_r"));
	lowerarm_r->SetupAttachment(GetMesh(), FName("lowerarm_r"));
    lowerarm_r->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    hand_l = CreateDefaultSubobject<UBoxComponent>(TEXT("hand_l"));
	hand_l->SetupAttachment(GetMesh(), FName("hand_l"));
    hand_l->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    hand_r = CreateDefaultSubobject<UBoxComponent>(TEXT("hand_r"));
	hand_r->SetupAttachment(GetMesh(), FName("hand_r"));
    hand_r->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    backpack = CreateDefaultSubobject<UBoxComponent>(TEXT("backpack"));
	backpack->SetupAttachment(GetMesh(), FName("backpack"));
    backpack->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    blanket = CreateDefaultSubobject<UBoxComponent>(TEXT("blanket"));
	blanket->SetupAttachment(GetMesh(), FName("backpack"));
    blanket->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    thigh_l = CreateDefaultSubobject<UBoxComponent>(TEXT("thigh_l"));
	thigh_l->SetupAttachment(GetMesh(), FName("thigh_l"));
    thigh_l->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    thigh_r = CreateDefaultSubobject<UBoxComponent>(TEXT("thigh_r"));
	thigh_r->SetupAttachment(GetMesh(), FName("thigh_r"));
    thigh_r->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    calf_l = CreateDefaultSubobject<UBoxComponent>(TEXT("calf_l"));
	calf_l->SetupAttachment(GetMesh(), FName("calf_l"));
    calf_l->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    calf_r = CreateDefaultSubobject<UBoxComponent>(TEXT("calf_r"));
	calf_r->SetupAttachment(GetMesh(), FName("calf_r"));
    calf_r->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    foot_l = CreateDefaultSubobject<UBoxComponent>(TEXT("foot_l"));
	foot_l->SetupAttachment(GetMesh(), FName("foot_l"));
    foot_l->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    foot_r = CreateDefaultSubobject<UBoxComponent>(TEXT("foot_r"));
	foot_r->SetupAttachment(GetMesh(), FName("foot_r"));
    foot_r->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
}
```



### 在`BP_BlasterCharacter`里处理

为了方便挨个调整，首先先暂停动画`pause anims`

然后把所有的`BoxComponent`的`Visible`都改成false，胶囊体的也是，然后依次打开调整位置和缩放使其略微大于Mesh

![1703850551809](pics\1703850551809.png)





# Frame Package

## 将HitBox打包成一个结构体

### 在`BlasterCharacter`里处理每帧打包

```cpp
USTRUCT(BlueprintType)
struct FBoxInformation
{
    GENERATED_BODY()
        
    UPROPERTY()
    FVector Location;
    
    UPROPERTY()
    FRotator Rotation;
    
    UPROPERTY()
    FVector BoxExtent;
};

USTRUCT(BlueprintType)
struct FFramePackage
{
    GENERATED_BODY()
        
    UPROPERTY()
    float Time;

    UPROPERTY()
    TMap<FName, FBoxInformation> HitBoxInfo;
};


private:
	UPROPERTY(VisibleAnywhere)
	ULagCompensationComponent* LagCompensation;
```



```cpp
#include "Blaster/BlasterComponents/LagCompensationComponent.h"

ABlasterCharacter::ABlasterCharacter()
{
    // ...
    LagCompensation = CreateDefaultSubobject<ULagCompensationComponent>(TEXT("LagCompensation"));
}
void ABlasterCharacter::PostInitializeComponents()
{
    // ...
    if(LagCompensation)
    {
        LagCompensation->Character = this;
        if(Controller)
        {
            LagCompensation->Controller = Cast<ABlasterPlayerController>(Controller);
        }
    	
    }
    
}
```



### 在`LagCompensationComponent`添加几个变量存储BlasterCharacter和BlasterPlayerController

```cpp
public:
	friend class ABlasterCharacter;

private:
	UPROPERTY()
    ABlasterCharacter* Character;

	UPROPERTY()
	ABlasterPlayerController* Controller;
```







# Saving a Frame Package

## 保存帧数据

### 在`BlasterCharacter`添加容器存储hitbox

```cpp
public:
	UPROPERTY()
	TMap<FName, UBoxComponent*> HitCollisionBoxes;
```



把每个hitbox都加到map里

```cpp
ABlasterCharacter::ABlasterCharacter()
{
    // ...
    HitCollisionBoxes.Add(FName("head"), head);
}
```



### 在`LagCompensationComponent`里处理

```cpp
public:
	void ShowFramePackage(const FFramePackage& Package, const FColor& Color);

protected:
	void SaveFramePackage(FFramePackage& Package);
```



为了观察结果所以在`BeginPlay`里调用一次看看效果

```cpp
#include "Blaster/Character/BlasterCharacter.h"
#include "Components/BoxComponent.h"
#include "DrawDebugHelpers.h"


void ULagCompensationComponent::BeginPlay()
{
	Super::BeginPlay();
	
    FFramePackage Package;
    SaveFramePackage(Package);
    ShowFramePackage(Package, FColor::Orange);
}

void ULagCompensationComponent::ShowFramePackage(const FFramePackage& Package, const FColor& Color)
{
    for(auto& BoxInfo : Package.HitBoxInfo)
    {
        DrawDebugBox(
        	GetWorld(),
            BoxInfo.Value.Location,
            BoxInfo.Value.BoxExtent,
            FQuat(BoxInfo.Value.Rotation),
            Color,
            true
        );
    }
}

void ULagCompensationComponent::SaveFramePackage(FFramePackage& Package)
{
    Character = Character == nullptr ? Cast<ABlasterCharacter>(GetOwner()) : Character;
    if(!Character)
    {
        return;
    }
    
    Package.Time = GetWorld()->GetTimeSeconds();
    
    for(auto& BoxPair : Character->HitCollisionBoxes)
    {
        FBoxInformation BoxInformation;
        BoxInformation.Location = BoxPair.Value->GetComponentLocation();
        BoxInformation.Rotation = BoxPair.Value->GetComponentRotation();
        BoxInformation.BoxExtent = BoxPair.Value->GetScaledBoxExtent();
        
        Package.HitBoxInfo.Add(BoxPair.Key, BoxInformation);
    }
}
```







# Frame History

## 帧历史队列

存储过去几秒的帧数据包

### 在`LagCompensationComponent`里处理

用双向列表`TDoubleLinkedList`来存

```cpp
protected:
	void SaveFrameHistory();

private:
	TDoubleLinkedList<FFramePackage> FrameHistory;

	UPROPERTY(EditAnywhere)
    float MaxRecordTime = 4.0f;
```



修改一下`ShowFramePackage`，看看存储的效果

```cpp
void ULagCompensationComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

    SaveFrameHistory();
}

void ULagCompensationComponent::SaveFrameHistory()
{
    if(FrameHistory.Num() <= 1)
    {
        FFramePackage ThisFrame;
        SaveFramePackage(ThisFrame);
        FrameHistory.AddHead(ThisFrame);
    }
    else
    {
        float HistoryLength = FrameHistory.GetHead()->GetValue().Time - FrameHistory.GetTail()->GetValue().Time;
        while(HistoryLength > MaxRecordTime)
        {
            FrameHistory.RemoveNode(FrameHistory.GetTail());
            HistoryLength = FrameHistory.GetHead()->GetValue().Time - FrameHistory.GetTail()->GetValue().Time;
        }
        
        FFramePackage ThisFrame;
        SaveFramePackage(ThisFrame);
        FrameHistory.AddHead(ThisFrame);
        
        ShowFramePackage(ThisFrame, FColor::Red);
    }
}

void ULagCompensationComponent::ShowFramePackage(const FFramePackage& Package, const FColor& Color)
{
	for (auto& BoxInfo : Package.HitBoxInfo)
	{
		DrawDebugBox(
			GetWorld(),
			BoxInfo.Value.Location,
			BoxInfo.Value.BoxExtent,
			FQuat(BoxInfo.Value.Rotation),
			Color,
			false,
            4.0f
		);
	}
}
```





# Rewinding Time

## 服务端的时间倒带算法

射击的客户端申请校验，`HitCharacter`是被命

首先先校验客户端传来的命中时间是否合法

接着用双指针找到命中时间处在服务端存储的列表中的哪两个节点之间

然后用插值算法根据双指针指向的各自位置和朝向算出命中时间那一刻该角色的位置和朝向

最后判断是否命中

```
ServerSideRewind(TraceStart, HitLocation, HitCharacter, HitTime)
{
	// check HitTime valid.
	if HitTime < OldestHistoryTime or HitTime > NewestHistoryTime:
		return
	
	// find two nearest frames between hitTime
	OlderFrame = YoungerFrame = ListHead
	
	while OlderTime > HitTime:
        OlderFrame = NextFrame
        if OlderTime > HitTime:
        	YoungerFrame = OlderFrame
    
    // Interpolate between two frames's locations and rotations
    BoxHit = Interpolate(OlderFrame, YoungerFrame)
    
    // check hit character 
    CheckHit(HitLocation, BoxHit)
}
```



### 在`BlasterCharacter`里把`LagCompensationComponent`暴露出来

```cpp
public:
	FORCEINLINE ULagCompensationComponent* GetLagCompensation() const { return LagCompensation; }
```





### 在`LagCompensationComponent`里实现

```cpp
public:
	void ServerSideRewind(ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize& HitLocation, float HitTime);
```



```cpp
void ULagCompensationComponent::ServerSideRewind(ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize& HitLocation, float HitTime)
{
    bool bReturn = 
        !HitCharacter ||
        !HitCharacter->GetLagCompensation() ||
        !HitCharacter->GetLagCompensation()->FrameHistory.GetHead() ||
        !HitCharacter->GetLagCompensation()->FrameHistory.GetTail();
    
    if(bReturn)
    {
        return;
    }
    
    bool bShouldInterpolate = true;
    
    const TDoubleLinkedList<FFramePackage>& History = HitCharacter->GetLagCompensation()->FrameHistory;
    const float OldestHistoryTime = History.GetTail()->GetValue().Time;
    const float NewestHistoryTime = History.GetHead()->GetValue().Time;
    
    if(OldestHistoryTime > HitTime)
    {
        return;
    }
    
    FFramePackage FrameToCheck;
    if(OldestHistoryTime == HitTime)
    {
        bShouldInterpolate = false;
        FrameToCheck = History.GetTail()->GetValue();
    }
    if(NewestHistoryTime <= HitTime)
    {
        bShouldInterpolate = false;
        FrameToCheck = History.GetHead()->GetValue();
    }
    
    TDoubleLinkedList<FFramePackage>::TDoubleLinkedListNode* Younger = History.GetHead();
    TDoubleLinkedList<FFramePackage>::TDoubleLinkedListNode* Older = Younger;
    
    while(Older->GetValue().Time > HitTime)
    {
        if(!Older->GetNextNode())
        {
            break;
        }
        Older = Older->GetNextNode();
        
        if(Older->GetValue().Time > HitTime)
        {
            Younger = Older;
        }
    }
    
    
    if(Older->GetValue().Time == HitTime)
    {
        FrameToCheck = Older->GetValue();
        bShouldInterpolate = false;
    }
    
    if(bShouldInterpolate)
    {
        
    }
}
```







# Interp Between Frames

## 在两帧之间插值



```
FMath::VInterpTo(Current, Target, DeltaTime, InterpSpeed)
```

`Current`到`Target`向量之间的距离`Distance`用于计算从起点开始的移动方向`DeltaMove`

```
DeltaMove = Distance * FMath::Clamp(DeltaTime * InterpSpeed, 0, 1)
```

在`Tick`里调用`VInterpTo`越频繁，`DeltaMove`越小，移动越平滑



### 继续实现`LagCompensationComponent`的`ServerSideRewind`里的Interpolation

类似于`FMath::VInterpTo`

```
Distance = YoungerTime - OlderTime
InterpFraction = (HitTime - OlderTime) / Distance
```



```cpp
protected:
	FFramePackage InterpBetweenFrames(const FFramePackage& OlderFrame, const FFramePackage& YoungerFrame, float HitTime);
```



```cpp
FFramePackage ULagCompensationComponent::InterpBetweenFrames(const FFramePackage& OlderFrame, const FFramePackage& YoungerFrame, float HitTime)
{
    const float Distance = YoungerFrame.Time - OlderFrame.Time;
    const float InterpFraction = FMath::Clamp((HitTime - OlderFrame.Time) / Distance, 0.0f, 1.0f);
    
    FFramePackage InterpFramePackage;
    InterpFramePackage.Time = HitTime;
    
    for(auto& YoungerPair : YoungerFrame.HitBoxInfo)
    {
        const FName& BoxInfoName = YoungerPair.Key;
        const FBoxInformation& OlderBox = OlderFrame.HitBoxInfo[BoxInfoName];
        const FBoxInformation& YoungerBox = YoungerFrame.HitBoxInfo[BoxInfoName];
        
        FBoxInformation InterpBoxInfo;
        InterpBoxInfo.Location = FMath::VInterpTo(OlderBox.Location, YoungerBox.Location, 1.0f, InterpFraction);
        InterpBoxInfo.Rotation = FMath::RInterpTo(OlderBox.Rotation, YoungerBox.Rotation, 1.0f, InterpFraction);
        InterpBoxInfo.BoxExtent = YoungerBox.BoxExtent;
        
        InterpFramePackage.HitBoxInfo.Add(BoxInfoName, InterpBoxInfo);
    }
    
    return InterpFramePackage;
}
```







# Confirming the Hit

## 用插值得到的碰撞体结果来判断是否命中

### 在`LagCompensationComponent`里处理

`ConfirmHit` 负责判断是否命中且爆头

在移动HitBox前先存一份当前位置，用于之后复位

在开始射线追踪前先禁用CharacterMesh的碰撞，并打开头部HitBox的碰撞，先判断是否爆头，这样如果爆头了的话可以不用再考虑其他HitBox，如果没命中的话再打开其他HitBox再做一次射线检测

最后复原当前位置以及各个Hitbox的碰撞属性

```cpp
USTRUCT(BlueprintType)
struct FServerSideRewindResult
{
	GENERATED_BODY()

	UPROPERTY()
	bool bHitConfirmed;

	UPROPERTY()
	bool bHeadShot;
};


protected:
	FServerSideRewindResult ConfirmHit(const FFramePackage& Package, ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize& HitLocation);

	void CacheBoxPositions(ABlasterCharacter* HitCharacter, FFramePackage& OutFramePackage);

	void MoveBoxes(ABlasterCharacter* HitCharacter, const FFramePackage& Package);

	void ResetHitBoxes(ABlasterCharacter* HitCharacter, const FFramePackage& Package);

	void EnableCharacterMeshCollision(ABlasterCharacter* HitCharacter, ECollisionEnabled::Type CollisionEnabled);
```



```cpp
FServerSideRewindResult ULagCompensationComponent::ConfirmHit(const FFramePackage& Package, ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize& HitLocation)
{
    if(!HitCharacter)
    {
        return FServerSideRewindResult();
    }
    
    FFramePackage CurrentFrame;
    CacheBoxPositions(HitCharacter, CurrentFrame);
    MoveBoxes(HitCharacter, Package);
    EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::NoCollision);
    
    UBoxComponent* HeadBox = HitCharacter->HitCollisionBoxes[FName("head")];
    HeadBox->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
    HeadBox->SetCollisionResponseToChannel(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block);
    
    FHitResult ConfirmHitResult;
    const FVector TraceEnd = TraceStart + (HitLocation - TraceStart) * 1.25f;
    UWorld* World = GetWorld();
    if(World)
    {
        World->LineTraceSingleByChannel(
        	ConfirmHitResult,
            TraceStart,
            TraceEnd,
            ECollisionChannel::ECC_Visibility
        );
        
        if(ConfirmHitResult.bBlockingHit)
        {
        	ResetHitBoxes(HitCharacter, CurrentFrame);
            EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::QueryAndPhysics);
            return FServerSideRewindResult{true, true};
        }
        else
        {
            for(auto& HitBoxPair : HitCharacter->HitCollisionBoxes)
            {
                if(HitBoxPair.Value)
                {
                    HitBoxPair.Value->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
                HitBoxPair.Value->SetCollisionResponseToChannel(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block);
                }
            }
            
            World->LineTraceSingleByChannel(
                ConfirmHitResult,
                TraceStart,
                TraceEnd,
                ECollisionChannel::ECC_Visibility
            );
            
            if(ConfirmHitResult.bBlockingHit)
            {
                ResetHitBoxes(HitCharacter, CurrentFrame);
                EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::QueryAndPhysics);
                return FServerSideRewindResult{true, false};
            }
        }
    }
    
    ResetHitBoxes(HitCharacter, CurrentFrame);
    EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::QueryAndPhysics);
    return FServerSideRewindResult{false, false};
}

void ULagCompensationComponent::CacheBoxPositions(ABlasterCharacter* HitCharacter, FFramePackage& OutFramePackage)
{
    if(!HitCharacter)
    {
        return;
    }
    
    for(auto& HitBoxPair : HitCharacter->HitCollisionBoxes)
    {
        if(HitBoxPair.Value)
        {
            FBoxInformation BoxInfo;
            BoxInfo.Location = HitBoxPair.Value->GetComponentLocation();
            BoxInfo.Rotation = HitBoxPair.Value->GetComponentRotation();
            BoxInfo.BoxExtent = HitBoxPair.Value->GetScaledBoxExtent();
            
            OutFramePackage.HitBoxInfo.Add(HitBoxPair.Key, BoxInfo);
        }
    }
}

void ULagCompensationComponent::MoveBoxes(ABlasterCharacter* HitCharacter, const FFramePackage& Package)
{
    if(!HitCharacter)
    {
        return;
    }
    
    for(auto& HitBoxPair : HitCharacter->HitCollisionBoxes)
    {
        if(HitBoxPair.Value)
        {
            HitBoxPair.Value->SetWorldLocation(Package.HitBoxInfo[HitBoxPair.Key].Location);
            HitBoxPair.Value->SetWorldRotation(Package.HitBoxInfo[HitBoxPair.Key].Rotation);
            HitBoxPair.Value->SetBoxExtent(Package.HitBoxInfo[HitBoxPair.Key].BoxExtent);
        }
    }
}

void ULagCompensationComponent::ResetHitBoxes(ABlasterCharacter* HitCharacter, const FFramePackage& Package)
{
    if(!HitCharacter)
    {
        return;
    }
    
    for(auto& HitBoxPair : HitCharacter->HitCollisionBoxes)
    {
        if(HitBoxPair.Value)
        {
            HitBoxPair.Value->SetWorldLocation(Package.HitBoxInfo[HitBoxPair.Key].Location);
            HitBoxPair.Value->SetWorldRotation(Package.HitBoxInfo[HitBoxPair.Key].Rotation);
            HitBoxPair.Value->SetBoxExtent(Package.HitBoxInfo[HitBoxPair.Key].BoxExtent);
            HitBoxPair.Value->SetCollisionEnabled(ECollisionEnabled::NoCollision);
        }
    }
}

FServerSideRewindResult ULagCompensationComponent::EnableCharacterMeshCollision(ABlasterCharacter* HitCharacter, ECollisionEnabled::Type CollisionEnabled)
{
    if(!HitCharacter || !HitCharacter->GetMesh())
    {
        return;
    }
    
    HitCharacter->GetMesh()->SetCollisionEnabled(CollisionEnabled);
}

void ULagCompensationComponent::ServerSideRewind(ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize& HitLocation, float HitTime)
{
    // ...
    
    if (bShouldInterpolate)
	{
		FrameToCheck = InterpBetweenFrames(Older->GetValue(), Younger->GetValue(), HitTime);
	}
    
    return ConfirmHit(FrameToCheck, HitCharacter, TraceStart, HitLocation);
}
```







# Score Request

## 请求命中

### 修改`Weapon`里的一些变量成员

把`HitScan`类型的武器的伤害挪到`AWeapon`基类里

加个`bool`和`projectile`类型区分

```cpp
public:
	FORCEINLINE float GetDamage() const { return Damage; }

protected:
	UPROPERTY(EditAnywhere)
	float Damage = 20.0f;

	UPROPERTY(EditAnywhere)
	bool bUseServerSideRewind = false;

	UPROPERTY()
	ABlasterCharacter* BlasterOwnerCharacter;

	UPROPERTY()
	ABlasterPlayerController* BlasterOwnerController;
```





### 在`LagCompensation`里添加ServerRPC用于判断是否命中

```cpp
public:
	UFUNCTION(Server, Reliable)
    void ServerScoreRequest(ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize& HitLocation, float HitTime, AWeapon* DamageCauser);
```



之前加的`SaveFrameHistory`保存帧历史队列加个权限，只在服务端处理

```cpp
#include "Kismet/GameplayStatics.h"
#include "Blaster/Weapon/Weapon.h"

void ULagCompensationComponent::SaveFrameHistory()
{
    if(!Character || !Character->HasAuthority())
    {
        return;
    }
    // ...
}

void ULagCompensationComponent::ServerScoreRequest_Implementation(ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize& HitLocation, float HitTime, AWeapon* DamageCauser)
{
    FServerSideRewindResult Confirm = ServerSideRewind(HitCharacter, TraceStart, HitLocation, HitTime);
    
    if(HitCharacter && DamageCauser && Character && Confirm.bHitConfirmed)
    {
        UGameplayStatics::ApplyDamage(
        	HitCharacter,
            DamageCauser->GetDamage(),
            Character->Controller,
            DamageCauser,
            UDamageType::StaticClass()
        );
    }
}
```



### 在`BlasterPlayerController`里把客户端保存的服务端时间暴露出来

```cpp
public:
	float SingleTripTime = 0.0f;
```



```cpp
void ABlasterPlayerController::ClientReportServerTime_Implementation(float TimeOfClientRequest, float TimeServerReceivedClientRequest)
{
    float RoundTripTime = GetWorld()->GetTimeSeconds() - TimeOfClientRequest;
    SingleTripTime = 0.5 * RoundTripTime;
	float CurrentServerTime = TimeServerReceivedClientRequest + SingleTripTime;
	ClientServerDelta = CurrentServerTime - GetWorld()->GetTimeSeconds();
}
```



### 在`HitScanWeapon`里应用`ScoreRequest`用于请求造成伤害

服务端本地控制的角色或者服务端但是不勾选是否使用SSR的还是直接用`ApplyDamage`，客户端且武器类型需要使用`ServerSideRewind`的用`ServerScoreRequest`

```cpp
#include "Blaster/BlasterComponents/LagCompensationComponent.h"
#include "Blaster/PlayerController/BlasterPlayerController.h"

void AHitScanWeapon::Fire(const FVector& HitTarget)
{
    // ...
    if (FireHit.bBlockingHit)
    {
        // ...
        if (BlasterCharacter && InstigatorController)
        {
            // server side
            if (HasAuthority())
            {
                // not use ServerSideRewind or server local character
                if (BlasterOwnerCharacter && (!bUseServerSideRewind || BlasterOwnerCharacter->IsLocallyControlled()) && InstigatorController)
                {
                    UGameplayStatics::ApplyDamage(
                        BlasterCharacter,
                        Damage,
                        InstigatorController,
                        this,
                        UDamageType::StaticClass()
                    );
                }
            }
            
            if(!HasAuthority() && bUseServerSideRewind)
            {
                BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(OwnerPawn) : BlasterOwnerCharacter;
                BlasterOwnerController = BlasterOwnerController == nullptr ? Cast<ABlasterPlayerController>(InstigatorController) : BlasterOwnerController;
                if(BlasterOwnerCharacter && BlasterOwnerCharacter->GetLagCompensation() && BlasterOwnerController)
                {
                    BlasterOwnerCharacter->GetLagCompensation()->ServerScoreRequest(
                        BlasterCharacter,
                        Start,
                        HitTarget,
                        BlasterOwnerController->GetServerTime() - BlasterOwnerController->SingleTripTime,
                        this
                    );
                }
            }
        }
    }
}
```







# Server-Side Rewind for Shotguns

## 霰弹枪的`ServerSIdeRewind`

### 在`LagCompensation`里特殊处理霰弹枪的部分顺便重构前面写的代码

```cpp
USTRUCT(BlueprintType)
struct FFramePackage
{
	// ...
    UPROPERTY()
    ABlasterCharacter* Character;
};

USTRUCT(BlueprintType)
struct FShotgunServerSideRewindResult
{
	GENERATED_BODY()

	UPROPERTY()
	TMap<ABlasterCharacter*, uint32> HeadShots;

	UPROPERTY()
	TMap<ABlasterCharacter*, uint32> BodyShots;
};


protected:
	FFramePackage GetFrameToCheck(ABlasterCharacter* HitCharacter, float HitTime);

	FShotgunServerSideRewindResult ShotgunServerSideRewind(const TArray<ABlasterCharacter*>& HitCharacters, const FVector_NetQuantize& TraceStart, const TArray<FVector_NetQuantize>& HitLocations, float HitTime);

	FShotgunServerSideRewindResult ShotgunConfirmHit(const TArray<FFramePackage>& FramePackages, const FVector_NetQuantize& TraceStart, const TArray<FVector_NetQuantize>& HitLocation);
```



```cpp
void ULagCompensationComponent::SaveFramePackage(FFramePackage& Package)
{
    // ...
    Package.Character = Character;
}

FFramePackage ULagCompensationComponent::GetFrameToCheck(ABlasterCharacter* HitCharacter, float HitTime)
{
    bool bReturn =
		!HitCharacter ||
		!HitCharacter->GetLagCompensation() ||
		!HitCharacter->GetLagCompensation()->FrameHistory.GetHead() ||
		!HitCharacter->GetLagCompensation()->FrameHistory.GetTail();

	if (bReturn)
	{
		return FFramePackage();
	}

	bool bShouldInterpolate = true;

	const TDoubleLinkedList<FFramePackage>& History = HitCharacter->GetLagCompensation()->FrameHistory;
	const float OldestHistoryTime = History.GetTail()->GetValue().Time;
	const float NewestHistoryTime = History.GetHead()->GetValue().Time;

	if (OldestHistoryTime > HitTime)
	{
		return FFramePackage();
	}

	FFramePackage FrameToCheck;
	if (OldestHistoryTime == HitTime)
	{
		bShouldInterpolate = false;
		FrameToCheck = History.GetTail()->GetValue();
	}
	if (NewestHistoryTime <= HitTime)
	{
		bShouldInterpolate = false;
		FrameToCheck = History.GetHead()->GetValue();
	}

	TDoubleLinkedList<FFramePackage>::TDoubleLinkedListNode* Younger = History.GetHead();
	TDoubleLinkedList<FFramePackage>::TDoubleLinkedListNode* Older = Younger;

	while (Older->GetValue().Time > HitTime)
	{
		if (!Older->GetNextNode())
		{
			break;
		}
		Older = Older->GetNextNode();

		if (Older->GetValue().Time > HitTime)
		{
			Younger = Older;
		}
	}

	if (Older->GetValue().Time == HitTime)
	{
		FrameToCheck = Older->GetValue();
		bShouldInterpolate = false;
	}

	if (bShouldInterpolate)
	{
		FrameToCheck = InterpBetweenFrames(Older->GetValue(), Younger->GetValue(), HitTime);
	}
    
    return FrameToCheck;
}

FServerSideRewindResult ULagCompensationComponent::ServerSideRewind(ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize& HitLocation, float HitTime)
{
    FFramePackage FrameToCheck = GetFrameToCheck(HitCharacter, HitTime);
    return ConfirmHit(FrameToCheck, HitCharacter, TraceStart, HitLocation);
}

FShotgunServerSideRewindResult ULagCompensationComponent::ShotgunServerSideRewind(const TArray<ABlasterCharacter*>& HitCharacters, const FVector_NetQuantize& TraceStart, const TArray<FVector_NetQuantize>& HitLocations, float HitTime)
{
    TArray<FFramePackage> FramesToCheck;
    for(ABlasterCharacter* HitCharacter : HitCharacters)
    {
        FramesToCheck.Add(GetFrameToCheck(HitCharacter, HitTime));
    }
}
```





# Confirming Shotgun Hits

## 服务端检测霰弹枪命中结果

### 在`LagCompensation`里处理

和一般版本类似，区别是全都在`for-loop`里做

```cpp
FShotgunServerSideRewindResult ULagCompensationComponent::ShotgunConfirmHit(const TArray<FFramePackage>& FramePackages, const FVector_NetQuantize& TraceStart, const TArray<FVector_NetQuantize>& HitLocations)
{
    for(auto& Frame : FramePackages)
    {
        if(!Frame.Character)
        {
            return FShotgunServerSideRewindResult();
        }
    }
    
    UWorld* World = GetWorld();
	if (!World)
	{
		return FShotgunServerSideRewindResult();
	}
    
    FShotgunServerSideRewindResult ShotgunResult;
    TArray<FFramePackage> CurrentFrames;
    
    // save current frame info.
    for(auto& Frame : FramePackages)
    {       
        FFramePackage CurrentFrame;
        CurrentFrame.Character = Frame.Character;
        CacheBoxPositions(Frame.Character, CurrentFrame);
        CurrentFrames.Add(CurrentFrame);
        MoveBoxes(Frame.Character, Frame);
        EnableCharacterMeshCollision(Frame.Character, ECollisionEnabled::NoCollision);
    }
    
    // enable hitbox's collision
    for(auto& Frame : FramePackages)
    {
        UBoxComponent* HeadBox = Frame.Character->HitCollisionBoxes[FName("head")];
        HeadBox->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
        HeadBox->SetCollisionResponseToChannel(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block);
    }
    
    // check head shots
    for(auto& HitLocation : HitLocations)
    {
        FHitResult ConfirmHitResult;
        const FVector TraceEnd = TraceStart + (HitLocation - TraceStart) * 1.25f;

        World->LineTraceSingleByChannel(
            ConfirmHitResult,
            TraceStart,
            TraceEnd,
            ECollisionChannel::ECC_Visibility
        );
        
        ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(ConfirmHitResult.GetActor());
        if(BlasterCharacter)
        {
            if (ShotgunResult.HeadShots.Contains(BlasterCharacter))
			{
				ShotgunResult.HeadShots[BlasterCharacter]++;
			}
			else
			{
				ShotgunResult.HeadShots.Emplace(BlasterCharacter, 1);
			}
        }
    }
    
    // enable rest hitbox's collision and disable head hitbox's collision.
    for(auto& Frame : FramePackages)
    {
        for (auto& HitBoxPair : Frame.Character->HitCollisionBoxes)
		{
			if (HitBoxPair.Value)
			{
				HitBoxPair.Value->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
				HitBoxPair.Value->SetCollisionResponseToChannel(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block);
			}
		}
        
        UBoxComponent* HeadBox = Frame.Character->HitCollisionBoxes[FName("head")];
        HeadBox->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    }
    
    // check body hits.
    for(auto& HitLocation : HitLocations)
    {
        FHitResult ConfirmHitResult;
        const FVector TraceEnd = TraceStart + (HitLocation - TraceStart) * 1.25f;

        World->LineTraceSingleByChannel(
            ConfirmHitResult,
            TraceStart,
            TraceEnd,
            ECollisionChannel::ECC_Visibility
        );
        
        ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(ConfirmHitResult.GetActor());
        if(BlasterCharacter)
        {
            if (ShotgunResult.BodyShots.Contains(BlasterCharacter))
			{
				ShotgunResult.BodyShots[BlasterCharacter]++;
			}
			else
			{
				ShotgunResult.BodyShots.Emplace(BlasterCharacter, 1);
			}
        }
    }
    
    // reset character info and collisions.
    for(auto& Frame : CurrentFrames)
    {
        ResetHitBoxes(Frame.Character, Frame);
		EnableCharacterMeshCollision(Frame.Character, ECollisionEnabled::QueryAndPhysics);
    }
    
    return ShotgunResult;
}

FShotgunServerSideRewindResult ULagCompensationComponent::ShotgunServerSideRewind(const TArray<ABlasterCharacter*>& HitCharacters, const FVector_NetQuantize& TraceStart, const TArray<FVector_NetQuantize>& HitLocations, float HitTime)
{
    TArray<FFramePackage> FramesToCheck;
    for(ABlasterCharacter* HitCharacter : HitCharacters)
    {
        FramesToCheck.Add(GetFrameToCheck(HitCharacter, HitTime));
    }
    
    return ShotgunConfirmHit(FramesToCheck, TraceStart, HitLocations);
}
```







# Shotgun Score Request

## 霰弹枪版本的请求命中

### 在`LagCompensation`里处理



```cpp
public:
	UFUNCTION(Server, Reliable)
	void ShotgunServerScoreRequest(const TArray<ABlasterCharacter*>& HitCharacters, const FVector_NetQuantize& TraceStart, const TArray<FVector_NetQuantize>& HitLocations, float HitTime);
```



```cpp
void ULagCompensationComponent::ShotgunServerScoreRequest_Implementation(const TArray<ABlasterCharacter*>& HitCharacters, const FVector_NetQuantize& TraceStart, const TArray<FVector_NetQuantize>& HitLocations, float HitTime)
{
    FShotgunServerSideRewindResult Confirm = ShotgunServerSideRewind(HitCharacters, TraceStart, HitLocations, HitTime);
    
    for(auto& HitCharacter : HitCharacters)
    {
        if(!HitCharacter || !HitCharacter->GetEquippedWeapon() || !Character)
        {
            continue;
        }
        
        float TotalDamage = 0.0f;
        if(Confirm.HeadShots.Contains(HitCharacter))
        {
            TotalDamage += Confirm.HeadShots[HitCharacter] * HitCharacter->GetEquippedWeapon()->GetDamage();
            
        }
        
        if(Confirm.BodyShots.Contains(HitCharacter))
        {
            TotalDamage += Confirm.BodyShots[HitCharacter] * HitCharacter->GetEquippedWeapon()->GetDamage();
        }
        
        UGameplayStatics::ApplyDamage(
			HitCharacter,
			TotalDamage,
			Character->Controller,
			HitCharacter->GetEquippedWeapon(),
			UDamageType::StaticClass()
		);
    }
}
```







# Requesting a Shotgun Hit

## 处理霰弹枪的请求命中

### 在`Shotgun`里修改原本的内容

和普通Weapon类似，只有Server端本地控制的或者`bUseServerSideRewind=false`的才`ApplyDamage`，防止客户端一发子弹调用ServerRPC+ServerMulticast 算两次伤害

```cpp
#include "Blaster/BlasterComponents/LagCompensationComponent.h"
#include "Blaster/PlayerController/BlasterPlayerController.h"

void AShotgun::FireShotgun(const TArray<FVector_NetQuantize>& HitTargets)
{
    // ...

	AController* InstigatorController = OwnerPawn->GetController();
    TArray<ABlasterCharacter*> HitCharacters;
    
	for (auto HitPair : HitMap)
	{
		if (HitPair.Key && InstigatorController)
		{
            if (HasAuthority() && (!bUseServerSideRewind || OwnerPawn->IsLocallyControlled()))
            {
                UGameplayStatics::ApplyDamage(
                    HitPair.Key,
                    Damage * HitPair.Value,
                    InstigatorController,
                    this,
                    UDamageType::StaticClass()
                );
            }
            
            HitCharacters.Add(HitPair.Key);
		}
	}
    
    if (!HasAuthority() && bUseServerSideRewind)
    {
        BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(OwnerPawn) : BlasterOwnerCharacter;
        BlasterOwnerController = BlasterOwnerController == nullptr ? Cast<ABlasterPlayerController>(InstigatorController) : BlasterOwnerController;
        if (BlasterOwnerCharacter && BlasterOwnerCharacter->IsLocallyControlled() && BlasterOwnerCharacter->GetLagCompensation() && BlasterOwnerController)
        {
            BlasterOwnerCharacter->GetLagCompensation()->ShotgunServerScoreRequest(
                HitCharacters,
                Start,
                HitTargets,
                BlasterOwnerController->GetServerTime() - BlasterOwnerController->SingleTripTime
            );
        }
    }
}
```



### `LagCompensation`有些遗漏的部分要补上

前面给`FFramePackage`结构体加了个`Character`，`GetFrameToCheck`要补上

```cpp
FFramePackage ULagCompensationComponent::GetFrameToCheck(ABlasterCharacter* HitCharacter, float HitTime)
{
    // ...
    FrameToCheck.Character = HitCharacter;
    return FrameToCheck;
}
```



同一颗霰弹枪子弹命中头部后不应当继续命中该玩家的body

用map存一下，爆头的话后续检查body的时候就过滤掉

```cpp
FShotgunServerSideRewindResult ULagCompensationComponent::ShotgunConfirmHit(const TArray<FFramePackage>& FramePackages, const FVector_NetQuantize& TraceStart, const TArray<FVector_NetQuantize>& HitLocations)
{
    // ...
    TMap<FVector_NetQuantize, TSet<ABlasterCharacter*>> HitTargets;
    // ...
    // check head shots
    for (auto& HitLocation : HitLocations)
    {
        // ...
        if (BlasterCharacter)
        {
            // ...
            if (HitTargets.Contains(HitLocation))
			{
				HitTargets[HitLocation].FindOrAdd(BlasterCharacter);
			}
			else
			{
				TSet<ABlasterCharacter*> TargetSet;
				TargetSet.Add(BlasterCharacter);
				HitTargets.Emplace(HitLocation, TargetSet);
			}
        }
    }
    
    // check body hits
	for (auto& HitLocation : HitLocations)
    {
        // ...
        if (BlasterCharacter)
        {
            if (HitTargets.Contains(HitLocation))
			{
				if (HitTargets[HitLocation].Contains(BlasterCharacter))
				{
					continue;
				}
			}
            // ...
        }
    }
}
```





# Predict Projectile Path

## 预测子弹路径

```
Initial Velocity	初始速度及方向
TraceStart			起始位置
```

ue自带的`PredictProjectilePath()`能从`ProjectileTrace`获取到`HitResult`



### 在`Projectile里添加Server-Side Rewind 需要用的变量

`FVector_NetQuantize100`相比`FVector_NetQuantize`保存了小数点后两位的精确度，用于更高精度的保存方向信息



```cpp
public:
	bool bUseServerSideRewind = false;
	FVector_NetQuantize TraceStart;
	FVector_NetQuantize100 InitialVelocity;
	
	UPROPERTY(EditAnywhere)
	float InitialSpeed = 15000.0f;
```



### 在`ProjectileBullet`里处理

```cpp
protected:
	virtual void BeginPlay() override;
```



```cpp
AProjectileBullet::AProjectileBullet()
{
    // ...
    ProjectileMovementComponent->InitialSpeed = InitialSpeed;
    ProjectileMovementComponent->MaxSpeed = InitialSpeed;
}

void AProjectileBullet::BeginPlay()
{
    Super::BeginPlay();
    
    FPredictProjectilePathParams PathParams;
    PathParams.bTraceWithChannel = true;
    PathParams.bTraceWithCollision = true;
    PathParams.DrawDebugTime = 5.0f;
    PathParams.DrawDebugType = EDrawDebugTrace::ForDuration;
    PathParams.LaunchVelocity = GetActorForwardVector() * InitialSpeed;
    PathParams.MaxSimTime = 4.0f;
    PathParams.ProjectileRadius = 5.0f;
    PathParams.SimFrequency = 30.0f;
    PathParams.StartLocation = GetActorLocation();
    PathParams.TraceChannel = ECollisionChannel::ECC_Visibility;
    PathParams.ActorsToIgnore.Add(this);
    
    FPredictProjectilePathResult PathResult;
    UGameplayStatics::PredictProjectilePath(this, PathParams, PathResult);
}
```







# Post Edit Change Property

## 后处理蓝图中的属性更改

为了避免蓝图覆盖cpp中修改的属性内容，比如前面给Projectile加了个`InitialSpeed`的可编辑属性，在构造函数会用这个值修改`ProjectileMovement`的`InitialSpeed`和`MaxSpeed`，但是回到蓝图会发现并没有变化



### 在`ProjectileBullet`里处理

用`#if WITH_EDITOR`只在编辑器模式下处理

`GET_MEMBER_NAME_CHECKED`可以获取变量在Unreal中生成的唯一FName

```cpp
public:
#if WITH_EDITOR
	virtual void PostEditChangeProperty(FPropertyChangedEvent& Event) override;
#endif
```



```cpp
#if WITH_EDITOR
void AProjectileBullet::PostEditChangeProperty(FPropertyChangedEvent& Event)
{
    Super::PostEditChangeProperty(Event);
    
    FName PropertyName = Event.Property ? Event.Property->GetFName() : NAME_None;
    if(PropertyName == GET_MEMBER_NAME_CHECKED(AProjectileBullet, InitialSpeed))
    {
        if(ProjectileMovementComponent)
        {
            ProjectileMovementComponent->InitialSpeed = InitialSpeed;
			ProjectileMovementComponent->MaxSpeed = InitialSpeed;
        }
    }
}
#endif
```



### 给`ProjectileRocket`和`ProjectileGrenade`也加一下

改一改变量

```cpp
public:
#if WITH_EDITOR
	virtual void PostEditChangeProperty(FPropertyChangedEvent& Event) override;
#endif
```



```cpp
#if WITH_EDITOR
void AProjectileRocket::PostEditChangeProperty(FPropertyChangedEvent& Event)
{
	Super::PostEditChangeProperty(Event);

	FName PropertyName = Event.Property ? Event.Property->GetFName() : NAME_None;
	if (PropertyName == GET_MEMBER_NAME_CHECKED(AProjectileRocket, InitialSpeed))
	{
		if (RocketMovementComponent)
		{
			RocketMovementComponent->InitialSpeed = InitialSpeed;
			RocketMovementComponent->MaxSpeed = InitialSpeed;
		}
	}
}
#endif
```





# Spawning Projectiles Locally

## 客户端本地生成枪弹

![1704268264661](pics\1704268264661.png)

Server端产生的所有Projectile都不会使用SSR验证，只有非本地控制的角色使用开启了SSR的武器开火时产生的Projectile是仅服务端可见，其他情况产生的Projectile都是可进行网络同步复制给客户端的

Client端如果使用的武器是不开启SSR的，那么开火的时候不会产生Projectile，也不会使用SSR验证

使用开启了SSR的武器开火时，产生的Projectile都是本地的，只有本地控制的开火会调用SSR验证命中，非本地的不会请求验证伤害



总的来说，服务端具有权威性，Spawn的Projectile都可以在服务端直接计算伤害，只有非本地即客户端开火调用ServerRPC产生的Projectile是不需要复制的，因为他们客户端本地已经创建了一个Projectile了，客户端开启了SSR的武器要算伤害必须调用SSR由服务端裁定是否命中以及造成了多少伤害，本地创建的Projectile只用于碰撞检测来判断要不要调用SSR通知服务端进行裁定，如果武器没开启SSR则全权交由服务端进行碰撞检测以及伤害计算



### 修改`Projectile`的伤害变量的可见性使得能在`ProjectileWeapon`里设置

并把原本的`EditAnywhere`改掉，现在在cpp里设置了

```cpp
public:
	UPROPERTY(VisibleAnywhere)
    float Damage = 20.0f;
```



### 在`ProjectileWeapon`里分开处理两种Projectile

一种是走ServerSideRewind的，另一种是直接Replicated的

```cpp
private:
	UPROPERTY(EditAnywhere)
	TSubclassOf<AProjectile> ServerSideRewindProjectileClass;
```



```cpp
void AProjectileWeapon::Fire(const FVector& HitTarget)
{
    Super::Fire(HitTarget);

	if (!ProjectileClass)
	{
		return;
	}
    
    UWorld* World = GetWorld();
	if (!World)
    {
        return;
    }

	const USkeletalMeshSocket* MuzzleFlashSocket = GetWeaponMesh()->GetSocketByName(FName("MuzzleFlash"));
	if (!MuzzleFlashSocket)
	{
		return;
	}

	FTransform SocketTransform = MuzzleFlashSocket->GetSocketTransform(GetWeaponMesh());
	FVector ToTarget = HitTarget - SocketTransform.GetLocation();
	FRotator TargetRotation = ToTarget.Rotation();

	APawn* InstigatorPawn = Cast<APawn>(GetOwner());
	if (!InstigatorPawn)
	{
		return;
	}

	FActorSpawnParameters SpawnParams;
	SpawnParams.Owner = GetOwner();
	SpawnParams.Instigator = InstigatorPawn;

    AProjectile* SpawndProjectile = nullptr;
    
	if(bUseServerSideRewind)
    {
        if(InstigatorPawn->HasAuthority()) // server
        {
            if(InstigatorPawn->IsLocallyControlled()) // server, host - use replicated projectile
            {
                SpawndProjectile = World->SpawnActor<AProjectile>(
                    ProjectileClass, 
                    SocketTransform.GetLocation(),
                    TargetRotation, 
                    SpawnParams
                );
                if(SpawndProjectile)
                {
                    SpawndProjectile->bUseServerSideRewind = false;
                    SpawndProjectile->Damage = Damage;
                }
            }
            else // server, not locally controlled - spawn non-replicated projectile, no SSR
            {
                SpawndProjectile = World->SpawnActor<AProjectile>(
                    ServerSideRewindProjectileClass, 
                    SocketTransform.GetLocation(),
                    TargetRotation, 
                    SpawnParams
                );
                if(SpawndProjectile)
                {
                    SpawndProjectile->bUseServerSideRewind = false;
                }
            }
        }
        else // client , using SSR
        {
            if(InstigatorPawn->IsLocallyControlled()) // client, locally controlled - spawn non-replicated projectile, use SSR
            {
                SpawndProjectile = World->SpawnActor<AProjectile>(
                    ServerSideRewindProjectileClass, 
                    SocketTransform.GetLocation(),
                    TargetRotation, 
                    SpawnParams
                );
                if(SpawndProjectile)
                {
                    SpawndProjectile->bUseServerSideRewind = true;
                    SpawndProjectile->TraceStart = SocketTransform.GetLocation();
                    SpawndProjectile->InitialVelocity = SpawndProjectile->GetActorForwardVector() * SpawndProjectile->InitialSpeed;
                    SpawndProjectile->Damage = Damage;
                }
            }
            else // client, not locally controlled - spawn non-replicated projectile, not use SSR
            {
                SpawndProjectile = World->SpawnActor<AProjectile>(
                    ServerSideRewindProjectileClass, 
                    SocketTransform.GetLocation(),
                    TargetRotation, 
                    SpawnParams
                );
                if(SpawndProjectile)
                {
                    SpawndProjectile->bUseServerSideRewind = false;
                }
            }
        }
    }
    else // weapon not using SSR
    {
        if(InstigatorPawn->HasAuthority()) 
        {
            SpawndProjectile = World->SpawnActor<AProjectile>(
                    ProjectileClass, 
                    SocketTransform.GetLocation(),
                    TargetRotation, 
                    SpawnParams
                );
            if(SpawndProjectile)
            {
                SpawndProjectile->bUseServerSideRewind = false;
                SpawndProjectile->Damage = Damage;
            }
        }
    }	
}
```



### 在编辑器中创建ServerSideRewind使用的BP

复制一份`BP_ProjectileBullet`重命名为`BP_ServerSideRewindProjectile`

取消勾选`Replicates`



### 修改`BP_AssaultRifle`里的`ServerSideRewindProjectileClass`





# Hit Box Collision Type

## 添加一个单独的碰撞盒碰撞类型

### 在编辑器中新加一个碰撞类型

`ProjectSettings`->`Engine-Collision`->`New Object Channel`的Name命名为`HitBox`，`DefaultResponse`设置为`Ignore`



### 在`Blaster`里添加新的碰撞通道宏定义

```cpp
#define ECC_HitBox ECollisionChannel::ECC_GameTraceChannel2
```



### 在`BlasterCharacter`里修改HitBox的`CollisionObjectType`

只阻挡`ECC_HitBox`

```cpp
ABlasterCharacter::ABlasterCharacter()
{
    // ...
    for(auto& Box : HitCollisionBoxes)
    {
        if(Box.Value)
        {
            Box.Value->SetCollisionObjectType(ECC_HitBox);
            Box.Value->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);
            Box.Value->SetCollisionResponseToChannel(ECC_HitBox, ECollisionResponse::ECR_Block);
            Box.Value->SetCollisionEnabled(ECollisionEnabled::NoCollision);
        }
    }
}
```



### 在`LagCompensation`里更新`HitScan`的检测通道

把所有的`ECollisionChannel::ECC_Visibility`都换成`ECC_HitBox`

加个`DrawDebugBox` 显示一下命中的是哪个Box

```cpp
#include "Blaster/Blaster.h"


FServerSideRewindResult ULagCompensationComponent::ConfirmHit(const FFramePackage& Package, ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize& HitLocation)
{
    // ...
    if (ConfirmHitResult.Component.IsValid())
    {
        UBoxComponent* Box = Cast<UBoxComponent>(ConfirmHitResult.Component);
        if (Box)
        {
            DrawDebugBox(GetWorld(), Box->GetComponentLocation(), Box->GetScaledBoxExtent(), FQuat(Box->GetComponentRotation()), FColor::Red, false, 8.f);
        }
    }
}
```







# Projectile Server-Side Rewind

## 枪弹的服务端回退

### 在`LagCompensation`里处理

```cpp
public:
	FServerSideRewindResult ProjectileServerSideRewind(ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize100& InitialVelocity, float HitTime);

protected:
	FServerSideRewindResult ProjectileConfirmHit(const FFramePackage& Package, ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize100& InitialVelocity, float HitTime);
```



```cpp
FServerSideRewindResult ULagCompensationComponent::ProjectileServerSideRewind(ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize100& InitialVelocity, float HitTime)
{
    FFramePackage FrameToCheck = GetFrameToCheck(HitCharacter, HitTime);
    return ProjectileConfirmHit(FrameToCheck, HitCharacter, TraceStart, InitialVelocity, HitTime);
}

FServerSideRewindResult ULagCompensationComponent::ProjectileConfirmHit(const FFramePackage& Package, ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize100& InitialVelocity, float HitTime)
{
    if (!HitCharacter)
	{
		return FServerSideRewindResult();
	}

	UWorld* World = GetWorld();
	if (!World)
	{
		return FServerSideRewindResult();
	}

	FFramePackage CurrentFrame;
	CacheBoxPositions(HitCharacter, CurrentFrame);
	MoveBoxes(HitCharacter, Package);
	EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::NoCollision);

	UBoxComponent* HeadBox = HitCharacter->HitCollisionBoxes[FName("head")];
	HeadBox->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
	HeadBox->SetCollisionResponseToChannel(ECC_HitBox, ECollisionResponse::ECR_Block);

	FPredictProjectilePathParams PathParams;
    PathParams.bTraceWithCollision = true;
    PathParams.MaxSimTime = MaxRecordTime;
    PathParams.LaunchVelocity = InitialVelocity;
    PathParams.StartLocation = TraceStart;
    PathParams.SimFrequency = 15.0f;
    PathParams.ProjectileRadius = 5.0f;
    PathParams.TraceChannel = ECC_HitBox;
    PathParams.ActorsToIgnore.Add(GetOwner());
    PathParams.DrawDebugTime = 5.0f;
	PathParams.DrawDebugType = EDrawDebugTrace::ForDuration;
    
	FPredictProjectilePathResult PathResult;
    UGameplayStatics::PredictProjectilePath(
    	this,
        PathParams,
        PathResult
    );

	// head shot
	if (PathResult.HitResult.bBlockingHit)
	{
		/*if (PathResult.HitResult.Component.IsValid())
		{
			UBoxComponent* Box = Cast<UBoxComponent>(PathResult.HitResult.Component);
			if (Box)
			{
				DrawDebugBox(GetWorld(), Box->GetComponentLocation(), Box->GetScaledBoxExtent(), FQuat(Box->GetComponentRotation()), FColor::Red, false, 8.f);
			}
		}*/

		ResetHitBoxes(HitCharacter, CurrentFrame);
		EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::QueryAndPhysics);
		return FServerSideRewindResult{ true, true };
	}
	else
	{
		for (auto& HitBoxPair : HitCharacter->HitCollisionBoxes)
		{
			if (HitBoxPair.Value)
			{
				HitBoxPair.Value->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
				HitBoxPair.Value->SetCollisionResponseToChannel(ECC_HitBox, ECollisionResponse::ECR_Block);
			}
		}

		UGameplayStatics::PredictProjectilePath(
            this,
            PathParams,
            PathResult
        );

		// hit other hitboxs
		if (PathResult.HitResult.bBlockingHit)
		{
			/*if (PathResult.HitResult.Component.IsValid())
			{
				UBoxComponent* Box = Cast<UBoxComponent>(PathResult.HitResult.Component);
				if (Box)
				{
					DrawDebugBox(GetWorld(), Box->GetComponentLocation(), Box->GetScaledBoxExtent(), FQuat(Box->GetComponentRotation()), FColor::Green, false, 8.f);
				}
			}*/

			ResetHitBoxes(HitCharacter, CurrentFrame);
			EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::QueryAndPhysics);
			return FServerSideRewindResult{ true, false };
		}
	}
	
	// no hit
	ResetHitBoxes(HitCharacter, CurrentFrame);
	EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::QueryAndPhysics);
	return FServerSideRewindResult{ false, false };
}
```







# Projectile Score Request

## 添加客户端使用的请求命中的`ServerRPC`

### 在`LagCompensation`里处理

```cpp
public:
	UFUNCTION(Server, Reliable)
	void ProjectileServerScoreRequest(ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize100& InitialVelocity, float HitTime);
```



```cpp
void ULagCompensationComponent::ProjectileServerScoreRequest_Implementation(ABlasterCharacter* HitCharacter, const FVector_NetQuantize& TraceStart, const FVector_NetQuantize100& InitialVelocity, float HitTime)
{
    FServerSideRewindResult Confirm = ProjectileServerSideRewind(HitCharacter, TraceStart, InitialVelocity, HitTime);

	if (HitCharacter && Character && Character->GetEquippedWeapon() && Confirm.bHitConfirmed)
	{
		UGameplayStatics::ApplyDamage(
			HitCharacter,
			Character->GetEquippedWeapon()->GetDamage(),
			Character->Controller,
			Character->GetEquippedWeapon(),
			UDamageType::StaticClass()
		);
	}
}
```





### 在`ProjectileBullet`里调用ServerRPC

```cpp
#include "Blaster/BlasterComponents/LagCompensationComponent.h"
#include "Blaster/PlayerController/BlasterPlayerController.h"
#include "Blaster/Character/BlasterCharacter.h"

void AProjectileBullet::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)
{
	ABlasterCharacter* OwnerCharacter = Cast<ABlasterCharacter>(GetOwner());
	if (OwnerCharacter)
	{
		ABlasterPlayerController* OwnerController = Cast<ABlasterPlayerController>(OwnerCharacter->Controller);
		if (OwnerController)
		{
			if(OwnerCharacter->HasAuthority() && (OwnerCharacter->IsLocallyControlled() || !bUseServerSideRewind))
            {
                UGameplayStatics::ApplyDamage(OtherActor, Damage, OwnerController, this, UDamageType::StaticClass());
                Super::OnHit(HitComp, OtherActor, OtherComp, NormalImpulse, Hit);
                return;
            }
            
            ABlasterCharacter* HitCharacter = Cast<ABlasterCharacter>(OtherActor);
            if(bUseServerSideRewind && OwnerCharacter->GetLagCompensation() && OwnerCharacter->IsLocallyControlled() && HitCharacter)
            {
                OwnerCharacter->GetLagCompensation()->ProjectileServerScoreRequest(
                	HitCharacter,
                    TraceStart,
                    InitialVelocity,
                    OwnerController->GetServerTime() - OwnerController->SingleTripTime
                );
            }
		}
	}


	Super::OnHit(HitComp, OtherActor, OtherComp, NormalImpulse, Hit);
}
```







# Limiting Server-Side Rewind

## 控制使用Server-Side Rewind的情景

ping值过高的情况下不再使用SSR



### 在`Weapon`里处理

把`bUseServerSideRewind`改成网络同步变量

添加一个函数用于绑定Controller的高ping委托，当触发时根据传参修改`bUseServerSideRewind`

```cpp
protected:
	UPROPERTY(Replicated, EditAnywhere)
	bool bUseServerSideRewind = false;

	bool bUseServerSideRewindBack = false;

	UFUNCTION()
	void OnPingTooHigh(bool bPingTooHigh);
```



```cpp
void AWeapon::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	// ...
	DOREPLIFETIME_CONDITION(AWeapon, bUseServerSideRewind, COND_OwnerOnly);
}

void AWeapon::BeginPlay()
{
	// ...

	if (HasAuthority())
	{
		bUseServerSideRewindBack = bUseServerSideRewind;
	}
}

void AWeapon::OnPingTooHigh(bool bPingTooHigh)
{
    bUseServerSideRewind = !bPingTooHigh;
}

void AWeapon::OnEquipped()
{
    // ...
    if (HasAuthority())
	{
		bUseServerSideRewind = bUseServerSideRewindBack;
	}
    BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(GetOwner()) : BlasterOwnerCharacter;
	if (BlasterOwnerCharacter)
	{
		BlasterOwnerController = BlasterOwnerController == nullptr ? Cast<ABlasterPlayerController>(BlasterOwnerCharacter->Controller) : BlasterOwnerController;
		if (BlasterOwnerController && HasAuthority() && !BlasterOwnerController->HighPingDelegate.IsBound())
		{
			BlasterOwnerController->HighPingDelegate.AddDynamic(this, &ThisClass::OnPingTooHigh);
		}
	}
}

void AWeapon::OnDropped()
{
    // ...
    BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(GetOwner()) : BlasterOwnerCharacter;
	if (BlasterOwnerCharacter)
	{
		BlasterOwnerController = BlasterOwnerController == nullptr ? Cast<ABlasterPlayerController>(BlasterOwnerCharacter->Controller) : BlasterOwnerController;
		if (BlasterOwnerController && HasAuthority() && BlasterOwnerController->HighPingDelegate.IsBound())
		{
			BlasterOwnerController->HighPingDelegate.RemoveDynamic(this, &ThisClass::OnPingTooHigh);
		}
	}
    
    if (HasAuthority())
	{
		bUseServerSideRewind = bUseServerSideRewindBack;
	}
}

void AWeapon::OnEquippedSecondary()
{
    // ...
    BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(GetOwner()) : BlasterOwnerCharacter;
	if (BlasterOwnerCharacter)
	{
		BlasterOwnerController = BlasterOwnerController == nullptr ? Cast<ABlasterPlayerController>(BlasterOwnerCharacter->Controller) : BlasterOwnerController;
		if (BlasterOwnerController && HasAuthority() && BlasterOwnerController->HighPingDelegate.IsBound())
		{
			BlasterOwnerController->HighPingDelegate.RemoveDynamic(this, &ThisClass::OnPingTooHigh);
		}
	}
    
    if (HasAuthority())
	{
		bUseServerSideRewind = bUseServerSideRewindBack;
	}
}
```



### 在`BlasterPlayerController`里处理

```cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FHighPingDelegate, bool, bPingTooHigh);

public:
	FHighPingDelegate HighPingDelegate;

private:
	UFUNCTION(Server, Reliable)
	void ServerReportPingStatus(bool bHighPing);
```



```cpp
void ABlasterPlayerController::CheckPing(float DeltaTime)
{
    // ...
    UE_LOG(LogTemp, Warning, TEXT("PlayerState->GetCompressedPing() * 4: %d"), PlayerState->GetCompressedPing() * 4);
    if (HighPingThreshold < PlayerState->GetCompressedPing() * 4)
    {
        // ...
        ServerReportPingStatus(true);
    }
    else
    {
        ServerReportPingStatus(false);
    }
}

void ABlasterPlayerController::ServerReportPingStatus_Implementation(bool bHighPing)
{
    HighPingDelegate.Broadcast(bHighPing);
}
```







# Swap Weapon Animation

## 客户端本地先播放切换武器的动画以减少延迟感

### 用已经有的动画资源切一个新的`Swap Montage`出来

`Equip_Rifle_Standing`开头和结尾在`lowerarm_r`各加一个key，中间把右手拖出来再加一个key，create Asset命名为`SwapWeapons`，创建完成后右击`SwapWeapons`->`Create Montage`命名为`Swap`  

打开`Swap Montage`把Slot改成`WeaponSlot`，`Rate Scale`改成1.5

在动画的中间15帧加一个Notify命名为`SwapAttachWeapons`，结尾48帧加一个Notify命名为`SwapFinished`

在动画的开头第5帧`Play Sound`用`GrenadeLauncher_Lower_Cue`



### 在`CombatState`里加个新的`State`

```cpp
UENUM(BlueprintType)
enum class ECombatState : uint8
{
	ECS_Unoccupied UMETA(DisplayName = "Unoccupied"),
	ECS_Reloading UMETA(DisplayName = "Reloading"),
	ECS_ThrowingGrenade UMETA(DisplayName = "Throwing Grenade"),
    ECS_SwappingWeapons UMETA(DisplayName = "Swapping Weapons"),
	ECS_MAX UMETA(DisplayName = "DefaultMAX")
};
```



### 在`BlasterCharacter`里处理

```cpp
public:
	void PlaySwapMontage();

	bool bFinishedSwapping = false;

private:
	UPROPERTY(EditAnywhere, Category = Combat)
	UAnimMontage* SwapMontage;
```



```cpp
void ABlasterCharacter::PlaySwapMontage()
{
	UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance();
	if (AnimInstance && SwapMontage)
	{
		AnimInstance->Montage_Play(SwapMontage);
	}
}

void ABlasterCharacter::EquipButtonPressed()
{
	if (bDisableGameplay)
	{
		return;
	}

	if (Combat)
	{
		if (HasAuthority())
		{
			// ...
		}
		else
		{
            if(Combat->CombatState == ECombatState::ECS_Unoccupied)
            {
                ServerEquipButtonPressed();
            }
			
            if(Combat->ShouldSwapWeapons() && !OverlappingWeapon)
            {
                PlaySwapMontage();
                Combat->CombatState = ECombatState::ECS_SwappingWeapons;
                bFinishedSwapping = false;
            }
		}
	}
}
```



### 在`CombatComponent`里处理同步

`CanFire`需要调换一下if的位置，`bLocallyReloading`要放在霰弹枪特判的后面才行

加两个动画蓝图调用的函数，分别处理切换武器和切换结束的内容，把原本`SwapWeapons`的内容均分了

`FinishSwapAttachWeapons`只有服务端能调用，否则客户端会换两次武器

```cpp
public:
	UFUNCTION(BlueprintCallable)
	void FinishSwap();

	UFUNCTION(BlueprintCallable)
	void FinishSwapAttachWeapons();
```



```cpp
void UCombatComponent::FinishSwap()
{
    if(Character && Character->HasAuthority())
    {
        CombatState = ECombatState::ECS_Unoccupied;
    }
    
    if(Character)
    {
        Character->bFinishedSwapping = true;
    }
    
    if(SecondaryWeapon)
    {
        SecondaryWeapon->EnableCustomDepth(true);
    }
}

void UCombatComponent::FinishSwapAttachWeapons()
{
	if (Character == nullptr || !Character->HasAuthority())
	{
		return;
	}
	PlayEquipWeaponSound(SecondaryWeapon);

	AWeapon* TempWeapon = EquippedWeapon;
	EquippedWeapon = SecondaryWeapon;
	SecondaryWeapon = TempWeapon;

	EquippedWeapon->SetWeaponState(EWeaponState::EWS_Equipped);
	EquippedWeapon->SetHUDAmmo();
	AttachActorToRightHand(EquippedWeapon);
	UpdateCarriedAmmo();

	SecondaryWeapon->SetWeaponState(EWeaponState::EWS_EquippedSecondary);
	AttachActorToBackpack(SecondaryWeapon);

	AutoReload();
}

void UCombatComponent::SwapWeapons()
{
    if(!Character || CombatState != ECombatState::ECS_Unoccupied)
    {
        return;
    }
    
    Character->PlaySwapMontage();
    Character->bFinishedSwapping =false;
    CombatState = ECombatState::ECS_SwappingWeapons;
    
	if(SecondaryWeapon)
    {
        SecondaryWeapon->EnableCustomDepth(false);
    }
}

void UCombatComponent::OnRep_CombatState()
{
    // ...
    case ECombatState::ECS_SwappingWeapons:
    {
        if(Character && !Character->IsLocallyControlled())
        {
            Character->PlaySwapMontage();
        }
        break;
    }
}

bool UCombatComponent::CanFire()
{
	if (!EquippedWeapon)
	{
		return false;
	}
    
	if (!EquippedWeapon->IsEmpty() && 
		bCanFire && 
		CombatState == ECombatState::ECS_Reloading && 
		EquippedWeapon->GetWeaponType() == EWeaponType::EWT_Shotgun)
	{
		return true;
	}
    
    if (bLocallyReloading)
	{
		return false;
	}

	return !EquippedWeapon->IsEmpty() && bCanFire && CombatState == ECombatState::ECS_Unoccupied;
}
```



### 在`Weapon`里处理副武器的后处理自定义颜色

开启靠调用`CombatComponent`的`FinishSwap`

关闭走`CombatComponent`的`SwapWeapons`

```cpp
void AWeapon::OnEquippedSecondary()
{
	// ...
    // EnableCustomDepth(true);
}
```



### 在`BlasterAnimInstance`里处理FABRIK

```cpp
void UBlasterAnimInstance::NativeUpdateAnimation(float DeltaTime)
{
    // ...
    bool bFABRIKOverride = BlasterCharacter->IsLocallyControlled() && 
        BlasterCharacter->GetCombatState() != ECombatState::ECS_ThrowingGrenade && 
        BlasterCharacter->bFinishedSwapping;
    if (bFABRIKOverride)
	{
		bUseFABRIK = !BlasterCharacter->IsLocallyReloading();
	}
}
```



### 在`BP_BlasterAnim`里处理Montage的Notify

`AnimNotify_SwapFinished`和`AnimNotify_SwapAttachWeapons`

![1704342924854](pics\1704342924854.png)







# Wrapping up Lag Compensation

## 可选的改进项

```
Client-Side Prediction for Reloading

Set Unoccupoed Status Immediately When Reloading

Rockets and Grenades

Change the Hit Target when Confirming a Hit
```







# Cheating and Validation

## 服务端验证数据防止作弊

### Code injection

```
PEEK commands
POKE commands
Injecting .dlls into the game
```



### Network Traffic Forgery



### Bugs/Vulnerabilities



### Memory Editing



### 在`CombatCompensation`里用`Validation`校验开火速率

在`UFUNCTION`里加上`WithValidation`，然后编写对应函数`XX_Validate`的版本

```cpp
public:
	UFUNCTION(Server, Reliable, WithValidation)
	void ServerFire(const FVector_NetQuantize& TraceHitTarget, float FireDelay);

	UFUNCTION(Server, Reliable, WithValidation)
	void ServerShotgunFire(const TArray<FVector_NetQuantize>& TraceHitTargets, float FireDelay, WithValidation);
```



```cpp
// , EquippedWeapon->FireDelay

bool UCombatComponent::ServerFire_Validate(const FVector_NetQuantize& TraceHitTarget, float FireDelay)
{
    if(!EquippedWeapon)
    {
        return false;
    }
    
    bool bNearlyEqual = FMath::IsNearlyEqual(EquippedWeapon->FireDelay, FireDelay, 0.001f);
    return bNearlyEqual;
}

void UCombatComponent::ServerFire_Implementation(const FVector_NetQuantize& TraceHitTarget, float FireDelay)
{
	MulticastFire(TraceHitTarget);
}

bool UCombatComponent::ServerShotgunFire_Validate(const TArray<FVector_NetQuantize>& TraceHitTarget, float FireDelay)
{
	if (!EquippedWeapon)
	{
		return false;
	}

	bool bNearlyEqual = FMath::IsNearlyEqual(EquippedWeapon->FireDelay, FireDelay, 0.001f);
	return bNearlyEqual;
}

void UCombatComponent::ServerShotgunFire_Implementation(const TArray<FVector_NetQuantize>& TraceHitTargets, float FireDelay)
{
	MulticastShotgunFire(TraceHitTargets);
}
```



