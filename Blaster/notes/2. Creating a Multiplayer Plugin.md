# Testing Multiplayer

## 用蓝图测试多人连接情况

创建一个新的关卡`Lobby`

简单测试直接在蓝图里拖就行

按下`数字键盘1` 的时候打开`Lobby` 关卡并通过`Options` 设置该进程实例为监听服务器

按下`数字键盘2` 的时候尝试连接监听服务器

![1701228326128](pics\1701228326128.png)



## 在关卡编辑器中测试

`Net Mode` 改成  `Play As Client` ，这样关卡编辑器的实例也是客户端

![1701230062755](pics\1701230062755.png)



# LAN Connection

上一节是用蓝图做的，这节把它改成用cpp做然后暴露接口为`BlueprintCallable`



## 用cpp实现OpenLevel的几种方法



### 关卡切换

https://docs.unrealengine.com/5.1/zh-CN/travelling-in-multiplayer-in-unreal-engine/

https://zhuanlan.zhihu.com/p/34397446





客户端1使用`OpenLobby` 通过 `Uworld->ServerTravel` 打开Lobby关卡并用`?listen`参数将自己的实例作为监听服务器

客户端2使用`CallOpenLevel`  通过`UGameplayStatics::OpenLevel` 进入客户端1创建的Lobby关卡

客户端3使用`CallClientTravel` 通过 `GameInstance->GetFirstLocalPlayerController` 借助 `GameInstance` 拿到 `PlayerController` ，然后用  `PlayerController->ClientTravel` 另一种方式进入客户端1创建的Lobby关卡

```cpp
UFUNCTION(BlueprintCallable)
void OpenLobby();

UFUNCTION(BlueprintCallable)
void CallOpenLevel(const FString& IPAddress);

UFUNCTION(BlueprintCallable)
void CallClientTravel(const FString& IPAddress);
```



```cpp
void AMPTestingCharacter::OpenLobby()
{
	UWorld* World = GetWorld();
	if (World)
	{
		// D:/UnrealProjects/MPTesting/MPTesting/Content/ThirdPerson/Maps/Lobby.umap
        // 用`/Game` 可以代替项目资源路径
        // `?listen` 和前面蓝图保持一致，作为监听服务器实例
		World->ServerTravel("/Game/ThirdPerson/Maps/Lobby?listen");
	}
}

void AMPTestingCharacter::CallOpenLevel(const FString& IPAddress)
{
	UGameplayStatics::OpenLevel(this, *IPAddress);
}

void AMPTestingCharacter::CallClientTravel(const FString& IPAddress)
{
	UGameInstance* GameInstance = GetGameInstance();
	if (GameInstance)
	{
		APlayerController* PlayerController = GameInstance->GetFirstLocalPlayerController();
		if (PlayerController)
		{
			PlayerController->ClientTravel(IPAddress, ETravelType::TRAVEL_Absolute);
		}
	}
}
```





### 在关卡编辑器中测试



![1701230163690](pics\1701230163690.png)







# Online Subsystem

由于进行网络连接需要知道对端的ip地址，而通常情况下无法得知路人的ip地址然后建立连接，所以主流做法是借助在线平台如Steam、xbox等服务提供商提供的接口来做

但是各家系统的接口都不完全相同，所以ue提供了一个抽象层`Online Subsystem` 用来处理和各种提供网络连接的在线平台服务商如steam、xbox等之间维护玩家在线登录连接等内容

这样开发者只需要专注于和ue的`Online Subsystem` 打交道即可，不需要每个服务商的每种写法都要单独学习





# Online Sessions

在`Engine.ini` 中指定目标平台是哪个系统，默认如下

```ini
[OnlineSubsystem]
DefaultPlatformService=<Platform>
```



在ue的cpp代码中可以通过如下方法拿到指向 `Online Subsystem` 的指针

```cpp
IOnlineSubsystem::Get()		-> return IOnlineSubsystem*
```



## Session Interface

用来管理Session的生命周期

通常一个Session的生命周期如下

```
Create Session
Wait for Players to join
Register Players
Start Session
Play
End Session
Unregister Players
Update Session or Destory Session
```

对应Session Interface的函数有

```
CreateSession()
FindSessions()
JoinSession()
StartSession()
DestorySession()
```



## 想要达成的功能概况

作为Host

```
Click Host Button --(Session settings)-->
Create Session->
Open Lobby Wait for visitors
```



作为Visitors

```
Click Join Button --(Search settings)-->
Find Sessions --(Pick a valid session)-->
Join Session --(Get the address)-->
Call ClientTravel Function to Join
```



最后将以上的功能封装成一个`Plugin`







# Configure For Steam

## 启用 `Online SubSystem Steam Plugin`

在`Plugins` 里找到`Online Subsystem Steam` 并启用



可以在vs的`Engine->UE5->Plugins->Online->OnlineSubsystemSteam` 看到源码



## 启用 `Online SubSystem Steam Module`

在`MenuSystem.Build.cs` 里添加

```
"OnlineSubsystemSteam", "OnlineSubsystem" 
```



## 在配置文件中配置 `Online Subsystem Steam`

https://docs.unrealengine.com/5.1/zh-CN/online-subsystem-steam-interface-in-unreal-engine/



按照官网文档在`DefaultEngine.ini` 添加相关内容，然后右击 `MenuSystem.uproject` 重新生成vs项目工程文件即可





# Accessing the Online Subsystem



`IOnlineSessionPtr` 是个`typedef`，本质就是`TSharedPtr<class IOnlineSession, ESPMode::ThreadSafe>` 

在构造函数里获取 `OnlineSubsystem` 并赋值给一个变量保存，供后面使用

`TEXT` 需要一个 `TCHAR*` ，而`OnlineSubsystem->GetSubsystemName()` 返回的是一个 `FName`，`FName` 调用 `ToString()` 转成一个 `FString` ，最后用`*` 把 `FString` 转成`TCHAR*`

```cpp
#include "OnlineSubsystem.h"
#include "Interfaces/OnlineSessionInterface.h"

// TSharedPtr<class IOnlineSession, ESPMode::ThreadSafe> OnlineSessionInterface;
IOnlineSessionPtr OnlineSessionInterface;


IOnlineSubsystem* OnlineSubsystem = IOnlineSubsystem::Get();
if (OnlineSubsystem)
{
    OnlineSessionInterface = OnlineSubsystem->GetSessionInterface();
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(
            -1,
            15.0f,
            FColor::Blue,
            FString::Printf(TEXT("found subsystem %s"), *OnlineSubsystem->GetSubsystemName().ToString())
        );
    }
}
```



## 测试

在关卡编辑器中是连不到steam的，连的是ue提供的本地的`Null`，所以需要打个包然后直接运行可执行文件才能看到





# Creating a Session

SessionInteface 用代理(Delegates) 来实现消息的通知

SessionInterface有一个Delegate List ，可以把要监听的事件注册到列表中，当事件触发的时候就可以通过回调函数来处理



## 创建委托变量和回调函数



跟到`FOnCreateSessionCompleteDelegate` 的定义出可以看到回调函数的参数有两个，一个`FName`的 `SessionName` ，另一个`bool` 的`bWasSuccessful`

```cpp
/**
 * Delegate fired when a session create request has completed
 *
 * @param SessionName the name of the session this callback is for
 * @param bWasSuccessful true if the async action completed without error, false if there was an error
 */
DECLARE_MULTICAST_DELEGATE_TwoParams(FOnCreateSessionComplete, FName, bool);
typedef FOnCreateSessionComplete::FDelegate FOnCreateSessionCompleteDelegate;
```



根据定义把委托变量和要绑定的回调函数定义好

然后再定义一个`BlueprintCallable` 的函数用来在蓝图里绑定键盘按键按下事件，触发创建Session

```cpp
#include "Interfaces/OnlineSessionInterface.h"

protected:
	UFUNCTION(BlueprintCallable)
	void CreateGameSession();

	void OnCreateSessionComplete(FName SessionName, bool bWasSuccessful);

private:
	FOnCreateSessionCompleteDelegate CreateSessionCompleteDelegate;
```



## 绑定回调函数到委托变量上

构造函数的初始化列表里直接初始化好 `CreateSessionCompleteDelegate ` 即可

`CreateUObject` 可以完成构造变量+绑定回调函数两件事

`ThisClass` 是个typedef，表示当前类，这里用来代替`AMenuSystemCharacter`

```cpp
AMenuSystemCharacter::AMenuSystemCharacter():
	CreateSessionCompleteDelegate(FOnCreateSessionCompleteDelegate::CreateUObject(this, &ThisClass::OnCreateSessionComplete))
{
```



## 创建GameSession



`NAME_GameSession` 是ue预定义好的`FName`

首先判断在构造函数赋值的 `OnlineSessionInterface` 是否存在，如果不存在就不需要跑下面的逻辑了

然后检查是否已存在`GameSession`了，如果存在的话要先释放已存在的

接下来把委托变量注册到`SessionInterface`的`Delegate List `上

最后执行`CreateSession`，需要一个唯一的网络ID，这个可以从LocalPlayer上拿到

`SessionSettings` 需要设置一些参数

```cpp
SessionSettings->bIsLANMatch = false; // 是否为局域网可见
SessionSettings->NumPublicConnections = 4;	// 最大连接数
SessionSettings->bAllowJoinInProgress = true; // 运行中是否允许加入
SessionSettings->bAllowJoinViaPresence = true; // steam的区域，是否允许同一区域的玩家加入
SessionSettings->bShouldAdvertise = true; // 是否公开到steam
SessionSettings->bUsesPresence = true; // 是否根据区域查找session
```



```cpp
void AMenuSystemCharacter::CreateGameSession()
{
	if (!OnlineSessionInterface->IsValid())
	{
		return;
	}

	auto ExistingSession = OnlineSessionInterface->GetNamedSession(NAME_GameSession);
	if (ExistingSession)
	{
		OnlineSessionInterface->DestorySession(NAME_GameSession);
	}

	OnlineSessionInterface->AddOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegate);

	TSharedPtr<FOnlineSessionSettings> SessionSettings = MakeShareable(new FOnlineSessionSettings());
    SessionSettings->bIsLANMatch = false;
	SessionSettings->NumPublicConnections = 4;
	SessionSettings->bAllowJoinInProgress = true;
	SessionSettings->bAllowJoinViaPresence = true;
	SessionSettings->bShouldAdvertise = true;
	SessionSettings->bUsesPresence = true;
    
	const ULocalPlayer* LocalPlayer = GetWorld()->GetFirstLocalPlayerFromController();
	OnlineSessionInterface->CreateSession(*LocalPlayer->GetPreferredUniqueNetId(), NAME_GameSession, *SessionSettings);
}
```



## 在回调里打印Session信息



在回调里打印下是否创建成功

```cpp
void AMenuSystemCharacter::OnCreateSessionComplete(FName SessionName, bool bWasSuccessful)
{
	if (bWasSuccessful)
	{
		if (GEngine)
		{
			GEngine->AddOnScreenDebugMessage(
				-1,
				15.0f,
				FColor::Blue,
				FString::Printf(TEXT("create session %s"), *SessionName.ToString())
			);
		}
	}
	else
	{
		if (GEngine)
		{
			GEngine->AddOnScreenDebugMessage(
				-1,
				15.0f,
				FColor::Red,
				FString(TEXT("create session failed."))
			);
		}
	}
}
```



## 打包测试

### 打开DefaultEngine.ini之前注释了的内容

```ini
; If using Sessions
; bInitServerOnClient=true

改成

bInitServerOnClient=true
```



### 对网络环境要求有点高，挂梯子才能创建session成功，开uu加速器都不行233







# Setup for Joining Game Sessions



## 创建加入游戏会话函数

```cpp
UFUNCTION(BlueprintCallable)
void JoinGameSession();
```



## 创建加入对话委托变量和回调函数

```cpp
void OnFindSessionsComplete(bool bWasSuccessful);

FOnFindSessionsCompleteDelegate FindSessionsCompleteDelegate;
```



## 绑定回调函数到委托上

在构造函数的初始化列表中绑定

```cpp
FindSessionsCompleteDelegate(FOnFindSessionsCompleteDelegate::CreateUObject(this, &ThisClass::OnFindSessionsComplete))
```





## 处理加入对话相关逻辑

### 查找已存在的sessions

 `FOnlineSessionSearch` 处理查找在线session相关内容

```cpp
SessionSearch->MaxSearchResults = 10000; // 用的appid=480是steam的示例appid，所以可能会有很多结果
SessionSearch->bIsLanQuery = false; // 不使用局域网查询
SessionSearch->QuerySettings.Set(SEARCH_PRESENCE, true, EOnlineComparisonOp::Equals); // 查找使用了区域设置的session
```



和创建session类似的处理方式

```cpp
 #include "OnlineSessionSettings.h"



void AMenuSystemCharacter::JoinGameSession()
{
    if(!OnlineSessionInterface.IsValid())
    {
        return;
    }
    
    OnlineSessionInterface->AddOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegate);
    
    TSharedPtr<FOnlineSessionSearch> SessionSearch = MakeShareable(new FOnlineSessionSearch());
    SessionSearch->MaxSearchResults = 10000;
    SessionSearch->bIsLanQuery = false;
    SessionSearch->QuerySettings.Set(SEARCH_PRESENCE, true, EOnlineComparisonOp::Equals);
    
    const ULocalPlayer* LocalPlayer = GetWorld()->GetFirstLocalPlayerFromController();
    OnlineSessionInterface->FindSessions(*LocalPlayer->GetPreferredUniqueNetId(), SessionSearch.ToSharedRef());
}
```



### 根据查找结果选择加入哪个session

搜索结果保存在上面创建的`TSharedPtr<FOnlineSessionSearch> SessionSearch` 变量里，所以把他改成类内的成员变量用来在 `OnFindSessionsComplete` 里处理结果

```cpp
TSharedPtr<FOnlineSessionSearch> SessionSearch;


void AMenuSystemCharacter::OnFindSessionsComplete(bool bWasSuccessful)
{
	for(auto Result : SessionSearch->SearchResults)
    {
        FString Id = Result.GetSessionIdStr();
        FString User = Result.Session.OwningUserName;
        if (GEngine)
		{
			GEngine->AddOnScreenDebugMessage(
				-1,
				15.0f,
				FColor::Cyan,
				FString::Printf(TEXT("Id: %s, User: %s"), *Id, *User)
			);
		}
    }
}
```





### 可能需要修改才能查找到session的情况

在创建session的`FOnlineSessionSettings` 里再额外设置一个`bUseLobbiesIfAvailable = true;`

```cpp
SessionSettings->bUseLobbiesIfAvailable = true;
```



重新生成项目临时文件比如`Binaries` ,`Intermediate` , `Saved`



在项目设置里的Packaging里有一个`List of maps to include in a packaged build ` 把地图加到数组里，`Content/` 以前的部分用`/Game/` 替换



## 在另一台机器上尝试连接

成功

![1701330740299](pics\1701330740299.png)





# Steam Regions

在Steam的设置里有个下载区域，就是代码里的 `Presece`





# Joining the Session

## 创建等待大厅

作为中转站接受其他玩家加入

当创建Session成功时就进入到Lobby这个level里并设定为监听服务器

```cpp
UWorld* World = GetWorld();
if(World)
{
    World->ServerTravel(FString("/Game/ThirdPerson/Maps/Lobby?listen"));
}
```



## 指定session的匹配类型

用于在Search的结果里过滤到想要的某个类型的session

在SessionSettings里可以用Set函数指定k-v键值对用来存储匹配类型

```cpp
SessionSettings->Set(FName("MatchType"), FString("FreeForAll"), EOnlineDataAdvertisementType::ViaOnlineServiceAndPing);
```



## 在searchresults里找到某个特定的匹配类型



用`SessionSettings.Get()` 可以拿到前面Set的值

```cpp
FString MatchType;
Result.Session.SessionSettings.Get(FName("MatchType"), MatchType);
if(MatchType == FString("FreeForAll"))
{
    if (GEngine)
		{
			GEngine->AddOnScreenDebugMessage(
            	-1,
                15.0f,
                FColor::Cyan,
                FString::Printf(TEXT("Joining Match Type: %s"), *MatchType)
            );
		}
}
```



## 加入会话



和上面类似，用委托来处理

```cpp
FOnJoinSessionCompleteDelegate JoinSessionCompleteDelegate;

void OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result);
```



在构造函数的初始化列表里绑定好

```cpp
JoinSessionCompleteDelegate(FOnJoinSessionCompleteDelegate::CreateUObject(this, &ThisClass::OnJoinSessionComplete))
```



当查找到正确`MatchType` 的session后执行Join

```cpp
void AMenuSystemCharacter::OnFindSessionsComplete(bool bWasSuccessful)
{
	if (!OnlineSessionInterface.IsValid())
	{
		return;
	}
	
	// for-loop on SearchResults
	OnlineSessionInterface->AddOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegate);
	const ULocalPlayer* LocalPlayer = GetWorld()->GetFirstLocalPlayerFromController();
	OnlineSessionInterface->JoinSession(*LocalPlayer->GetPreferredUniqueNetId(), NAME_GameSession, Result);
}
```



在Join的回调拿到`ClientTravel`所需的`Address`

```cpp
void AMenuSystemCharacter::OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result)
{
    if (!OnlineSessionInterface.IsValid())
	{
		return;
	}
    
    FString Address;
    if(OnlineSessionInterface->GetResolvedConnectString(NAME_GameSession, Address))
    {
        if(GEngine)
        {
            GEngine->AddOnScreenDebugMessage(
                -1,
                15.0f,
                FColor::Cyan,
                FString::Printf(TEXT("Connect string: %s"), *Address)
            );
        }
    }
}
```



## 用拿到的Address加入创建Session的用户创建的Lobby中



用PlayerController的ClientTravel

```cpp
UGameInstance* GameInstance = GetGameInstance();
if (GameInstance)
{
    APlayerController* PlayerController = GameInstance->GetFirstLocalPlayerController();
    if (PlayerController)
    {
        PlayerController->ClientTravel(Address, ETravelType::TRAVEL_Absolute);
    }
}
```





## 打包测试

打包前记得把新增的`Lobby`地图也加到`Package Settings`的`List of maps to include in a packaged build` 里





![1701335848437](pics\1701335848437.png)







# Creating a Plugin

`Plugin`是由若干个`Module` 构成的，`Module` 只包含c++代码和一个`.Build.cs`的文件



## 创建一个新插件

在关卡编辑器的Plugin设置里选择创建一个空白插件

然后在关卡编辑器的`Content browser` 的Settings里可以勾选上`Show Plugin Content`



如果创建失败了就把临时生成的项目二进制之类的文件删了然后重新生成一份项目文件重新构建





## 添加插件需要的依赖项

在插件的工程目录下有一个`xxx.uplugin` 文件，在`"Modules"` 后添加

```cpp
"Plugins": [
    {
        "Name": "OnlineSubsystem",
        "Enabled": true
    },
    {
        "Name": "OnlineSubsystemSteam",
        "Enabled": true
    }
]
```



在`xxx.Build.cs` 里添加需要的module

`PublicDependencyModuleNames` 和 `PrivateDependencyModuleNames` 的区别在于 `PrivateDependencyModuleNames`  的只能在private这个目录下的文件里可用

为了方便使用，直接在`PublicDependencyModuleNames` 里加

```cpp
"OnlineSubsystem",
"OnlineSubsystemSteam",
```





# Creating our Own Subsystem

需要一个生命周期从游戏开始而开始，游戏结束而结束，可以存在于不同的level间的类似`GameInstance`的一种父类来继承以处理`online multiplayer session`，有`GameInstanceSubsystem` 可以用

https://docs.unrealengine.com/5.1/en-US/programming-subsystems-in-unreal-engine/



这样继承该父类创建的子类对象会在`GameInstance`之后创建，并在`GameInstance` 销毁后析构



## 创建类

继承自`GameInstanceSubsystem`父类，选择创建给前面新加的`multiplayer sessions module`

添加完后要重启下vs项目才能在Plugins里看到新增的cpp类



```cpp
#include "Interfaces/OnlineSessionInterface.h"

public:
	UMultiplayerSessionsSubsystem();

private:
	IOnlineSessionPtr SessionInterface;
```



```cpp
#include "OnlineSubsystem.h"

UMultiplayerSessionsSubsystem::UMultiplayerSessionsSubsystem()
{
    IOnlineSubsystem* Subsystem = IOnlineSubsystem::Get();
    if(Subsystem)
    {
        SessionInterface = Subsystem->GetSessionInterface();
    }
}
```





# Session Interface Delegates

流程大致为

```
Construct delegate and bind delegate
->
Add to delegate list and store function return handle
->
After callback function execute, clear delegate from delegate list by using handle the pre-step stored.
```



## 添加公共函数

```cpp
public:
	void CreateSession(int32 NumPublicConnections, FString MatchType);
	void FindSessions(int32 MaxSearchResults);
	void JoinSession(const FOnlineSessionSearchResult& SessionResult);
	void DestroySession();
	void StartSession();
```



## 添加委托变量、存储Handle和回调函数

```cpp
private:
	FOnCreateSessionCompleteDelegate CreateSessionCompleteDelegate;
	FDelegateHandle CreateSessionCompleteDelegateHandle;

	FOnFindSessionsCompleteDelegate FindSessionCompleteDelegate;
	FDelegateHandle FindSessionCompleteDelegateHandle;

	FOnJoinSessionCompleteDelegate JoinSessionCompleteDelegate;
	FDelegateHandle JoinSessionCompleteDelegateHandle;

	FOnDestroySessionCompleteDelegate DestroySessionCompleteDelegate;
	FDelegateHandle DestroySessionCompleteDelegateHandle;

	FOnStartSessionCompleteDelegate StartSessionCompleteDelegate;
	FDelegateHandle StartSessionCompleteDelegateHandle;

protected:
	void OnCreateSessionComplete(FName SessionName, bool bWasSuccessful);
	void OnFindSessionsComplete(bool bWasSuccessful);
	void OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result);
	void OnDestroySessionComplete(FName SessionName, bool bWasSuccessful);
	void OnStartSessionComplete(FName SessionName, bool bWasSuccessful);
```



在构造函数的初始化列表里绑定好

```cpp
UMultiplayerSessionsSubsystem::UMultiplayerSessionsSubsystem():
	CreateSessionCompleteDelegate(FOnCreateSessionCompleteDelegate::CreateUObject(this, &ThisClass::OnCreateSessionComplete)),

FindSessionCompleteDelegate(FOnFindSessionsCompleteDelegate::CreateUObject(this, &ThisClass::OnFindSessionsComplete)),
	JoinSessionCompleteDelegate(FOnJoinSessionCompleteDelegate::CreateUObject(this, &ThisClass::OnJoinSessionComplete)),
	DestroySessionCompleteDelegate(FOnDestroySessionCompleteDelegate::CreateUObject(this, &ThisClass::OnDestroySessionComplete)),
	StartSessionCompleteDelegate(FOnStartSessionCompleteDelegate::CreateUObject(this, &ThisClass::OnStartSessionComplete))
{
```





# The Menu Class

## 创建菜单类

继承自UserWidget

处理一些可见性、能否聚焦、鼠标控制相关

```cpp
public:
	UFUNCTION(BlueprintCallable)
	void MenuSetup();

void UMenu::MenuSetup()
{
    AddToViewport();
    SetVisibility(ESlateVisibility::Visible);
    bIsFocusable = true;
    
    UWorld* World = GetWorld();
    if(World)
    {
        APlayerController* PlayerController = World->GetFirstPlayerController();
        if(PlayerController)
        {
            FInputModeUIOnly InputModeData;
            InputModeData.SetWidgetToFocus(TakeWidget());
            InputModeData.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock);
            PlayerController->SetInputMode(InputModeData);
            PlayerController->SetShowMouseCursor(true);
        }
    }
}
```



### 为插件添加UMG、Slate、SlateCore Modules

加到`PublicDependencyModuleNames` 里即可

```cpp
"UMG",
"Slate",
"SlateCore",
```



## 创建Menu的widget blueprint

简单拖个widget

![1701344831716](pics\1701344831716.png)



在 `Graph` 的 `Class Settings` 里把 `Parent Class` 改成前面创建的`Menu`



## 在关卡蓝图里创建WBP_Menu

![1701344928937](pics\1701344928937.png)

`Create Widget` 之后执行前面在cpp里写的 `Menu Setup`

![1701345070741](pics\1701345070741.png)







# Accessing our Subsystem

## 在Menu类中添加Button变量处理Clicked事件



用`UPROPERTY(meta = (BindWidget))` 将cpp中的变量和widget里的同名Button控件绑定

```cpp
private:
	UPROPERTY(meta = (BindWidget))
	UButton* HostButton;

	UPROPERTY(meta = (BindWidget))
	UButton* JoinButton;

	UFUNCTION()
	void HostButtonClicked();

	UFUNCTION()
    void JoinButtonClicked();
```



```cpp
#include "Components/Button.h"

void UMenu::HostButtonClicked()
{
    if(GEngine)
    {
        GEngine->AddOnScreenDebugMessage(
            -1,
            15.0f,
            FColor::Yellow,
            FString(TEXT("Host Button Clicked"))
        );
    }
}

void UMenu::JoinButtonClicked()
{
    if(GEngine)
    {
        GEngine->AddOnScreenDebugMessage(
            -1,
            15.0f,
            FColor::Yellow,
            FString(TEXT("Join Button Clicked"))
        );
    }
}
```



### 找个地方绑定Clicked事件

```cpp
protected:
	virtual bool Initialize() override;
```



```cpp
bool UMenu::Initialize()
{
	if(!Super::Initialize())
	{
		return false;
	}
    
    if(HostButton)
    {
        HostButton->OnClicked.AddDynamic(this, &ThisClass::HostButtonClicked);
    }
    
    if(JoinButton)
    {
        JoinButton->OnClicked.AddDynamic(this, &ThisClass::JoinButtonClicked);
    }
	
	return true;
}
```



## 在Menu中使用 Multiplayer Session Subsystem



```cpp
private:
	UMultiplayerSessionSubsystem* MultiplayerSessionSubsystem;
```



因为` Multiplayer Session Subsystem`是在 `GameInstance` 之后才实例化的，所以此时可以拿到 `GameInstance`

```cpp
#include "MultiplayerSessionSubsystem.h"

void UMenu::MenuSetUp()
{
	// ...
    UGameInstance* GameInstance = GetGameInstance();
    if(GameInstance)
    {
        MultiplayerSessionSubsystem = GameInstance->GetSubsystem<UMultiplayerSessionSubsystem>();
    }
}

void UMenu::HostButtonClicked()
{
    // ...
    if(MultiplayerSessionSubsystem)
    {
        MultiplayerSessionSubsystem->CreateSession(4, FString("FreeForAll"));
    }
}
```





# Create Session

## 实现前面声明的CreateSession函数



在 `MultiplayerSessionsSubsystem` 类内设置一个`TSharedPtr<FOnlineSessionSettings>` 用来保存上一个session的设置

```cpp
private:
	TSharedPtr<FOnlineSessionSettings> LastSessionSettings;
```



先判断指针是否有效

然后判断是否已存在session，如果已存在则先销毁

然后绑定回调函数到委托列表中，并暂存返回的Handle句柄用于之后的创建session失败的处理

接着填充`SessionSettings`，如果Subsystem是`NULL`代表用的是本地的局域网络

最后执行`CreateSession`，如果失败了就用前面保存的Handle句柄删除委托列表里的绑定

```cpp
void UMultiplayerSessionsSubsystem::CreateSession(int32 NumPublicConnections, FString MatchType)
{
	if(!SessionInterface.IsValid())
    {
        return;
    }
    
    auto ExistingSession = SessionInterface->GetNamedSession(NAME_GameSession);
    if(ExistingSession)
    {
        SessionInterface->DestroySession(NAME_GameSession);
    }
    
    CreateSessionCompleteDelegateHandle = SessionInterface->AddOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegate);
    LastSessionSettings = MakeShareable(new FOnlineSessionSettings());
    LastSessionSettings->bIsLANMatch = IOnlineSubsystem::Get()->GetSubsystemName() == "NULL" ? true : false;
    LastSessionSettings->NumPublicConnections = NumPublicConnections;
    LastSessionSettings->bAllowJoinInProgress = true;
    LastSessionSettings->bAllowJoinViaPresence = true;
    LastSessionSettings->bShouldAdvertise = true;
    LastSessionSettings->bUsesPresence = true;
    LastSessionSettings->bUseLobbiesIfAvailable = true;
    LastSessionSettings->Set(FName("MatchType"), MatchType, EOnlineDataAdvertisementType::ViaOnlineServiceAndPing);
    
    const ULocalPlayer* LocalPlayer = GetWorld()->GetFirstLocalPlayerFromController();
	if(!SessionInterface->CreateSession(*LocalPlayer->GetPreferredUniqueNetId(), NAME_GameSession, *LastSessionSettings))
    {
        SessionInterface->ClearOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegateHandle);
    }
}
```



## 通过点击前面做的Menu的HostButton来创建session并进入Lobby Level



```cpp
void UMenu::HostButtonClicked()
{
    // ...
    if (MultiplayerSessionSubsystem)
	{
		MultiplayerSessionSubsystem->CreateSession(4, FString("FreeForAll"));
        
        UWorld* World = GetWorld();
        if(World)
        {
            World->ServerTravel("/Game/ThirdPerson/Maps/Lobby?listen");
        }
	}
}
```



### 进入Lobby Level后要回撤之前Setup禁用的按键输入



```cpp
private:
	void MenuTearDown();
```



```cpp
void UMenu::MenuTearDown()
{
    RemoveFromParent();
    UWorld* World = GetWorld();
    if(World)
    {
        APlayerController* PlayerController = World->GetFirstPlayerController();
        if(PlayerController)
        {
            FInputModeGameOnly InputModeData;
            PlayerController->SetInputMode(InputModeData);
            PlayerController->SetShowMouseCursor(false);
        }
    }
}
```



### 找个地方处理调用`MenuTearDown`



ue5.1+没有` OnLevelRemovedFromWorld ` 了，所以改成

```cpp
virtual void NativeDestruct() override;
```



```cpp
void UMenu::NativeDestruct()
{
	MenuTearDown();

	Super::NativeDestruct();
}
```





## 在Menu的widget里添加若干个输入可以定制一些设置

在Menu类里加几个变量，在`MenuSetup`的时候赋值

`HostButtonClicked ` 里原本写死的 `CreateSession` 的参数也可以改成变量了

```cpp
private:
	int32 NumPublicConnections{4};
	FString MatchType{TEXT("FreeForAll")};
```



```cpp
void MenuSetup(int32 NumberOfPublicConnections = 4, FString TypeOfMatch = FString(TEXT("FreeForAll")));
```



```cpp
void UMenu::MenuSetup(int32 NumberOfPublicConnections, FString TypeOfMatch)
{
	// ...
	NumPublicConnections = NumberOfPublicConnections;
	MatchType = TypeOfMatch;
}


void UMenu::HostButtonClicked()
{
    // ...
    if (MultiplayerSessionSubsystem)
	{
		MultiplayerSessionSubsystem->CreateSession(NumPublicConnections, MatchType);
        
        UWorld* World = GetWorld();
        if(World)
        {
            World->ServerTravel("/Game/ThirdPerson/Maps/Lobby?listen");
        }
	}
}
```





## Character的蓝图里加个Esc按键触发退出游戏

之前一直是Alt+F4直接退的，连个`Quit Game` 蓝图节点就行







# Callbacks to our Subsystem Functions

为了解决在Subsystem能通知Menu 执行某些内容，需要自定义一些委托，Menu类注册这些自定义委托并执行callback



## 创建`MultiplayerSessionsSubsystem` 的自定义委托



在`MultiplayerSessionsSubsystem` 里创建

`Multicast` 表示可以广播给多个注册对象

`Dynamic` 表示可以序列化，由蓝图触发

```cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMultiplayerOnCreateSessionComplete, bool, bWasSuccessful);


public:
	FMultiplayerOnCreateSessionComplete MultiplayerOnCreateSessionComplete;
```



## 在 `Menu`类内创建委托绑定的回调

必须是`UFUNCTION` 的

```cpp
public:
	UFUNCTION()
	void OnCreateSession(bool bWasSuccessful);
```



## 注册回调函数到委托

在`MenuSetup` 里绑定

```cpp
void UMenu::MenuSetup(int32 NumOfPublicConnection /*= 4*/, FString TypeOfMatch /*= FString(TEXT("FreeForAll"))*/)
{
    // ...
    if(MultiplayerSessionsSubsystem)
    {
        MultiplayerSessionsSubsystem->MultiplayerOnCreateSessionComplete.AddDynamic(this, &ThisClass::OnCreateSession);
    }
}
```



## 在`MultiplayerSessionsSubsystem` 里广播自定义的委托

```cpp
void UMultiplayerSessionsSubsystem::CreateSession(int32 NumPublicConnections, FString MatchType)
{
	//...
    if (!SessionInterface->CreateSession(*LocalPlayer->GetPreferredUniqueNetId(), NAME_GameSession, *LastSessionSettings))
	{
		SessionInterface->ClearOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegateHandle);
        // broadcast false
        MultiplayerOnCreateSessionComplete.Broadcast(false);
	}
}

void UMultiplayerSessionsSubsystem::OnCreateSessionComplete(FName SessionName, bool bWasSuccessful)
{
    if(SessionInterface)
    {
        SessionInterface->ClearOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegateHandle);
    }
	MultiplayerOnCreateSessionComplete.Broadcast(bWasSuccessful);
}
```



## 把前面点击按钮就创建lobby挪到回调里



```cpp
void UMenu::OnCreateSession(bool bWasSuccessful)
{
    if(bWasSuccessful)
    {
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(
                -1,
                15.0f,
                FColor::Yellow,
                FString(TEXT("create session success"))
            );
        }
        
        UWorld* World = GetWorld();
		if (World)
		{
			World->ServerTravel(FString("/Game/ThirdPerson/Maps/Lobby?listen"));
		}
    }
    else
    {
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(
                -1,
                15.0f,
                FColor::Red,
                FString(TEXT("create session failed"))
            );
        }
    }
}
```





# More Subsystem Delegates

## 给其他的session操作创建对应的自定义委托



因为`SearchSessions`的结果`FOnlineSessionSearchResult`不是蓝图所能使用的`UCLASS()`，所以不能直接用`Dynamic`

`JoinSession` 的结果`EOnJoinSessionCompleteResult::Type` 也不能直接通过蓝图传递，所以也不用`Dynamic`

```cpp
DECLARE_MULTICAST_DELEGATE_TwoParams(FMultiplayerOnFindSessionsComplete, const TArray<FOnlineSessionSearchResult>& SessionResults, bool bWasSuccessful);

DECLARE_MULTICAST_DELEGATE_OneParam(FMultiplayerOnJoinSessionComplete, EOnJoinSessionCompleteResult::Type Result);

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMultiplayerOnDestroySessionComplete, bool, bWasSuccessful);

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMultiplayerOnStartSessionComplete, bool, bWasSuccessful);


public:
	FMultiplayerOnFindSessionsComplete MultiplayerOnFindSessionsComplete;
	FMultiplayerOnJoinSessionComplete MultiplayerOnJoinSessionComplete;
	FMultiplayerOnDestroySessionComplete MultiplayerOnDestroySessionComplete;
	FMultiplayerOnStartSessionComplete MultiplayerOnStartSessionComplete;
```



## 在`Menu`中编写注册的回调函数

`FindSession`  和 `JoinSession` 不用`UFUNCTION()`



```cpp
protected:
	void OnFindSessions(const TArray<FOnlineSessionSearchResult>& SessionResults, bool bWasSuccessful);
	void OnJoinSession(EOnJoinSessionCompleteResult::Type Result);
	UFUNCTION()
	void OnDestroySession(bool bWasSuccsssful);
	UFUNCTION()
	void OnStartSession(bool bWasSuccessful);
```





## 在`Menu`中编写委托绑定和执行的回调函数

对于不是`Dynamic`的委托，用`AddUObject` 来绑定回调到委托上

```cpp
MultiplayerSessionsSubsystem->MultiplayerOnFindSessionsComplete.AddUObject(this, &ThisClass::OnFindSessions);
MultiplayerSessionsSubsystem->MultiplayerOnJoinSessionComplete.AddUObject(this, &ThisClass::OnJoinSession);
MultiplayerSessionSubsystem->MultiplayerOnDestroySessionComplete.AddDynamic(this, &ThisClass::OnDestroySession);
MultiplayerSessionSubsystem->MultiplayerOnStartSessionComplete.AddDynamic(this, &ThisClass::OnStartSession);
```





# Join Sessions from the Menu



## 实现`Menu`  的 `JoinButtonClicked` 逻辑

```cpp
void UMenu::JoinButtonClicked()
{
	if(MultiplayerSessionsSubsystem)
    {
        MultiplayerSessionsSubsystem->FindSessions(10000);
    }
}
```



## 实现`MultiplayerSessionsSubsystem` 的`FindSessions`和Subsystem委托执行的回调

和之前做的类似，定义一个变量暂存上一次的设置

```cpp
private:
	TSharedPtr<FOnlineSessionSearch> LastSessionSearch;
```



大体流程和create类似，先绑定委托到`Sessioninterface`  并拿到Handle

然后给settings赋值

最后执行`FindSessions`，如果失败了就清除绑定的`Handle` 并且通知`Menu` 结果

```cpp
void UMultiplayerSessionsSubsystem::FindSessions(int32 MaxSearchResults)
{
	if(!Sessioninterface.IsValid())
    {
        return;
    }
    
    FindSessionsCompleteDelegateHandle = Sessioninterface->AddOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegate);
    
    LastSessionSearch = MakeShareable(new FOnlineSessionSearch());
    LastSessionSearch->MaxSearchResults = MaxSearchResults;
    LastSessionSearch->bIsLanQuery = IOnlineSubsystem::Get()->GetSubsystemName() == "NULL" ? true : false;
    LastSessionSearch->QuerySettings.Set(SEARCH_PRESENCE, true, EOnlineComparisonOp::Equals);

	const ULocalPlayer* LocalPlayer = GetWorld()->GetFirstLocalPlayerFromController();
	if(!Sessioninterface->FindSessions(*LocalPlayer->GetPreferredUniqueNetId(), LastSessionSearch.ToSharedRef()))
    {
        Sessioninterface->ClearOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegateHandle);
        MultiplayerOnFindSessionsComplete.Broadcast(TArray<FOnlineSessionSearchResult>(), false);
    }
}


void UMultiplayerSessionsSubsystem::OnFindSessionsComplete(bool bWasSuccessful)
{
	if (SessionInterface)
	{
		SessionInterface->ClearOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegateHandle);
	}
    
    if(LastSessionSearch->SearchResults.Num() <= 0)
    {
        MultiplayerOnFindSessionsComplete.Broadcast(TArray<FOnlineSessionSearchResult>(), false);
        return;
    }
	
	MultiplayerOnFindSessionsComplete.Broadcast(LastSessionSearch->SearchResults, bWasSuccessful);
}
```





## 处理`MultiplayerSessionsSubsystem` 委托通知 `Menu`的`OnFindSessions`回调函数 



目前的版本只需要找到符合`MatchType`的第一个`Session`即可

```cpp
void UMenu::OnFindSessions(const TArray<FOnlineSessionSearchResult>& SearchResults, bool bWasSuccessful)
{
    if(!MultiplayerSessionsSubsystem)
    {
        return;
    }
    
	for(auto Result : SearchResults)
    {
        FString SettingsValue;
        Result.Session.SessionSettings.Get(FName("MatchType"), SettingsValue);
        
        if(SettingsValue == MatchType)
        {
            MultiplayerSessionsSubsystem->JoinSession(Result);
            break;
        }
    }
}
```



## 处理`MultiplayerSessionSubsystem` 的`JoinSession`



和`CreateSession` 、`FindSessions` 类似

先判断`SessionInterface` 是否合法

然后绑定委托，拿到`Handle`

最后执行`JoinSession`



等`subsystem` 委托执行的回调触发，用自定义的委托广播相应的结果给`Menu`

```cpp
void UMultiplayerSessionsSubsystem::JoinSession(const FOnlineSessionSearchResult& SessionResult)
{
	if(!SessionInterface.IsValid())
    {
        MultiplayerOnJoinSessionComplete.Broadcast(EOnJoinSessionCompleteResult::UnknownError);
        return;
    }
    
    JoinSessionCompleteDelegateHandle = Sessioninterface->AddOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegate);
    
    const ULocalPlayer* LocalPlayer = GetWorld()->GetFirstLocalPlayerFromController();
    if(!SessionInterface->JoinSession(*LocalPlayer->GetPreferredUniqueNetId(), NAME_GameSession, SessionResult))
    {
        SessionInterface->ClearOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegateHandle);
        MultiplayerOnJoinSessionComplete.Broadcast(EOnJoinSessionCompleteResult::UnknownError);
    }
}

void UMultiplayerSessionsSubsystem::OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result)
{
    if(SessionInterface)
    {
        SessionInterface->ClearOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegateHandle);
    }
	
    MultiplayerOnJoinSessionComplete.Broadcast(Result);
}
```



## 处理`MultiplayerSessionsSubsystem` 委托通知 `Menu`的`OnJoinSession`回调函数 

`Menu`要拿到`MultiplayerSessionsSubsystem` 的`IOnlineSessionPtr SessionInterface`

用`ClientTravel`进入`Lobby`

```cpp
void UMenu::OnJoinSession(EOnJoinSessionCompleteResult::Type Result)
{
	IOnlineSubsystem* Subsystem = IOnlineSubsystem::Get();
	if (Subsystem)
	{
		IOnlineSessionPtr SessionInterface = Subsystem->GetSessionInterface();
        if(SessionInterface.IsValid())
        {
            FString Address;
            if(SessionInterface->GetResolvedConnectString(NAME_GameSession, Address))
            {
                UGameInstance* GameInstance = GetGameInstance();
                if (GameInstance)
                {
                    APlayerController* PlayerController = GameInstance->GetFirstLocalPlayerController();
                    if (PlayerController)
                    {
                        PlayerController->ClientTravel(Address, ETravelType::TRAVEL_Absolute);
                    }
                }
            }
        }
	}
}
```



## 打个包测试一下

网络要求有点高，A机器点击Join要等好几秒才能进入B机器Host的Lobby

![1701424919580](pics\1701424919580.png)





# Tracking Incoming Players

## 创建一个GameMode来追踪玩家加入和退出

在 `MenuSystem` 这个项目中创建而不是 `MultiplayerSessionsSubsystem`

继承自`AGameModeBase`

```cpp
public:
	virtual void PostLogin(APlayerController* NewPlayer) override;
	virtual void Logout(AController* Exiting) override;
```



```cpp
#include "GameFramework/GameStateBase.h"
#include "GameFramework/PlayerState.h"

void ALobbyGameMode::PostLogin(APlayerController* NewPlayer)
{
	Super::PostLogin(NewPlayer);
    
    if(GameState)
    {
        int32 NumberOfPlayers = GameState.Get()->PlayerArray.Num();
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(
                1,
                60.0f,
                FColor::Yellow,
                FString::Printf(TEXT("Players in game: %d"), NumberOfPlayers)
            );
            
            APlayerState* PlayerState = NewPlayer->GetPlayerState<APlayerState>();
            if(PlayerState)
            {
                FString PlayerName = PlayerState->GetPlayerName();
                GEngine->AddOnScreenDebugMessage(
                    -1,
                    60.0f,
                    FColor::Cyan,
                    FString::Printf(TEXT("%s has joined the game"), *PlayerName)
                );
            }
        }
    }
}

void ALobbyGameMode::Logout(AController* Exiting)
{
	Super::Logout(Exiting);
    
    if(GameState)
    {
        // Logout的时候PlayerArray还没删掉这个玩家，所以下面手动-1了
        int32 NumberOfPlayers = GameState.Get()->PlayerArray.Num();
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(
                1,
                60.0f,
                FColor::Yellow,
                FString::Printf(TEXT("Players in game: %d"), NumberOfPlayers - 1)
            );
            
            APlayerState* PlayerState = NewPlayer->GetPlayerState<APlayerState>();
            if(PlayerState)
            {
                FString PlayerName = PlayerState->GetPlayerName();
                GEngine->AddOnScreenDebugMessage(
                    -1,
                    60.0f,
                    FColor::Cyan,
                    FString::Printf(TEXT("%s has exited the game"), *PlayerName)
                );
            }
        }
    }
}
```



## 固定`MultiplayerSessionsSubsystem` `CreateSession`中的`BuildUniqueId`

这样可以让`Search Session` 的时候能看到不同Build版本的Session

```cpp
LastSessionSettings->BuildUniqueId = 1;
```



## 扩充一个Session能容纳的最大玩家数

`DefaultGame.ini` 里加上

```ini
[/Script/Engine.GameSession]
MaxPlayers=100
```



## 创建`BP_LobbyGameMode`

把`Default Pawn Class` 改成`ThirdPersonCharacter`

因为默认的Pawn没有`Movement Replicated`，会无法看到其他玩家的运动

### 修改`Lobby Level` 的`GameMode` 为`BP_LobbyGameMode`



## 打个包测试一下



![1701430703705](pics\1701430703705.png)





# Path to Lobby

把`Menu` 里 Hard Code的`Lobby Path`改成一个变量

```cpp
private:
	FString PathToLobby{ TEXT("")};

public:
	void MenuSetup(/**/, FString LobbyPath = FString(TEXT("/Game/ThirdPerson/Maps/Lobby")));
```



```cpp
void UMenu::MenuSetup(/**/, FString LobbyPath)
{
    PathToLobby = FString::Printf(TEXT("%s?listen"), *LobbyPath);
}

void UMenu::OnCreateSession(bool bWasSuccessful)
{
    // ...
    World->ServerTravel(PathToLobby);
}
```





# Polishing the Menu Subsystem



## 当`DestroySession`执行成功后才继续`CreateSession`



因为在`MultiplayerSessionsSubsystem` 的`CreateSession` 中，如果已存在Session，就会执行`DestorySession`，而这一过程需要时间，之前是在`DestorySession`函数调用后立刻就接着执行`CreateSession` 了，此时Session的服务端(steam)可能还没有Destroy掉，就会导致`CreateSession` 失败，因此要把已存在Session时的`CreateSession` 挪到`OnDestroySessionComplete` 里来调用

```cpp
private:
	bool bCreateSessionOnDestroy{false};
	int32 LastNumPublicConnections;
	FString LashMatchType;
```



```cpp
void UMultiplayerSessionsSubsystem::CreateSession(int32 NumPublicConnections, FString MatchType)
{
	// ...
    
    auto ExistingSession = SessionInterface->GetNamedSession(NAME_GameSession);
	if (ExistingSession)
	{
		bCreateSessionOnDestroy = true;
        LastNumPublicConnections = NumPublicConnections;
        LashMatchType = MatchType;
        
        DestroySession();
		return;
	}
    
    // ...
}

void UMultiplayerSessionsSubsystem::DestroySession()
{
	if(!SessionInterface.IsValid())
    {
        MultiplayerOnDestroySessionComplete.Broadcast(false);
        return;
    }
    
    DestroySessionCompleteDelegateHandle = SessionInterface->AddOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegate);
    
    if(!SessionInterface->DestroySession(NAME_GameSession))
    {
        SessionInterface->ClearOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegateHandle);
        MultiplayerOnDestroySessionComplete.Broadcast(false);
    }
}

void UMultiplayerSessionsSubsystem::OnDestroySessionComplete(FName SessionName, bool bWasSuccessful)
{
    if(SessionInterface)
    {
        SessionInterface->ClearOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegateHandle);
    }
    
	if(bWasSuccessful && bCreateSessionOnDestroy)
    {
        bCreateSessionOnDestroy = false;
        CreateSession(LastNumPublicConnections, LastMatchType);
    }
    
    MultiplayerOnDestroySessionComplete.Broadcast(bWasSuccessful);
}
```

## Menu里监听Destroy事件，收到后重新把Host按钮置为enabled
```cpp
void UMenu::OnDestroySession(bool bWasSuccessful)
{
	HostButton->SetIsEnabled(true);
}
```




## 在`Menu` 加一个`QuitButton`

在`MenuWidget`里加个`QuitButton`，在`OnClicked`事件触发的回调里连上`Quit Game` 蓝图节点



## 防止Button被短时间内多次点击



```cpp
void UMenu::HostButtonClicked()
{
    HostButton->SetIsEnabled(false);
    
    // ...
}

void UMenu::JoinButtonClicked()
{
    JoinButton->SetIsEnabled(false);
    
    // ...
}

void UMenu::OnCreateSession(bool bWasSuccessful)
{
    // ...
    else // failed to creating session
    {
        // ...
        HostButton->SetIsEnabled(true);
    }
}

void UMenu::OnFindSessions(const TArray<FOnlineSessionSearchResult>& SearchResults, bool bWasSuccessful)
{
    // ...
    if(!bWasSuccessful || SessionResults.Num() == 0)
    {
        JoinButton->SetIsEnabled(true);
    }
}

void UMenu::OnJoinSession(EOnJoinSessionCompleteResult::Type Result)
{
    // ...
    else
    {
        JoinButton->SetIsEnabled(true);
    }
}
```









