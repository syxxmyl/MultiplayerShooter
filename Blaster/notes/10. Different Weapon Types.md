# Rocket Projectiles

## 火箭弹类武器

### 创建`ProjectileRocket`类

继承自`Projectile`

`BP_ProejctileRocket`蓝图要改一些配置

`Damage`增大到100

`Impact Particles`选择`P_RocketLauncher_Explosion_01`

`Impact Sound`选择`RocketLauncher_Explosion_Cue`

`RocketMesh`选择`RocketLauncherA_Ammo`

`Box Extent`改成(14,3,3)

`Initial Speed`和`Max Speed`改成1500

`Projectile Gravity Scale`改成0

```cpp
public:
	AProjectileRocket();

protected:
	virtual void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit) override;

private:
	UPROPERTY(EditDefaultsOnly)
    float MinimumDamage = 10.0f;

	UPROPERTY(EditDefaultsOnly)
    float DamageInnerRadius = 200.0f;

	UPROPERTY(EditDefaultsOnly)
    float DamageOuterRadius = 500.0f;

	UPROPERTY(EditDefaultsOnly)
    float DamageFalloff = 1.0f;

	UPROPERTY(EditDefaultsOnly)
	UStaticMeshComponent* RocketMesh;
```

用`ApplyRadialDamageWithFalloff`造成依据半径衰减的伤害



```cpp
#include "Kismet/GameplayStatics.h"

AProjectileRocket::AProjectileRocket()
{
    RocketMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("RocketMesh"));
    RocketMesh->SetupAttachment(RootComponent);
    RocketMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
}

void AProjectileRocket::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)
{
    APawn* FiringPawn = GetInstigator();
    if(FiringPawn)
    {
        AController* FiringController = FiringPawn->GetController();
        if(FiringController)
        {
            UGameplayStatics::ApplyRadialDamageWithFalloff(
            	this,
                Damage,
                MinimumDamage,
                GetActorLocation(),
                DamageInnerRadius,
                DamageOuterRadius,
                DamageFalloff,
                UDamageType::StaticClass(),
                TArray<AActor*>(),
                this,
                FiringController
            );
        }
    }
    
    Super::OnHit(HitComp, OtherActor, OtherComp, NormalImpulse, Hit);
}
```



### 在`WeaponType`添加Rocket的武器类型枚举

```cpp
UENUM(BlueprintType)
enum class EWeaponType : uint8
{
	EWT_AssaultRifle UMETA(DisplayName = "Assault Rifle"),
    EWT_RocketLauncher UMETA(DisplayName = "Rocket Launcher"),
	EWT_MAX UMETA(DisplayName = "DefaultMAX"),
};
```



### 在`CombatComponent`里修改火箭弹的起始弹药携带量

```cpp
private:
	UPROPERTY(EditAnywhere)
	int32 StartingRocketAmmo = 8;
```



```cpp
void UCombatComponent::InitializeCarriedAmmo()
{
	CarriedAmmoMap.Emplace(EWeaponType::EWT_AssaultRifle, StartingARAmmo);
    CarriedAmmoMap.Emplace(EWeaponType::EWT_RocketLauncher, StartingRocketAmmo);
}
```



### 创建`BP_RocketLauncher`

从`ProjectileWeapon`派生蓝图

`ProjectileClass`选`BP_ProjectileRocket`

`Equip Sound`用`RocketLauncher_Raise_Cue`

`Ammo`和`MagCapacity`改成4

`Fire Delay`改成1

`Automatic`取消勾选

`Fire Animation`选`Fire_RocketLauncher_W`

`Crosshairs`选和突击步枪一样的对应的`Crosshair_XXX`

`Zoomed FOV`改成40，`Zoom Interp Speed`改成20

`WeaponType`用`Rocket Launcher`

`Weapon Mesh`用`Rocket_Launcher_A`

`Sphere Radius`改成80

`PickupWidget`里的`Space`改成`Screen`,`WidgetClass`为`WBP_PickupWidget`，勾选上`Draw at Desired Size`,在viewport里把PickupWidget往上调整一下让文字显示在武器上方



### 在`Rocket_Launcher_A`添加修改左手的`LeftHandSocket`

右击`Root_Bone`->`Add Socket`命名为`LeftHandSocket`

边调试边修改位置





# Rocket Trails

## 在火箭的后面添加一个尾焰和烟雾

### 创建一个新的`Niagara System`

#### 新建Material`M_TrailSmoke` 作为粒子系统的外观

`Blend Mode`改成`Translucent`

添加`ParticleSubUV`->`Texture`选择`T_SmokeSubUV_8x8`->右击`ParticleSubUV`选择`Convert to Parameter`命名为`T_SmokeFlipbook`->`ParticleSubUV`的RGB节点连上`Multiply`另一端用 新添加`ParticleColor`的`RGB`->`Emissive Color`

`ParticleSubUV`的`A`->`Multiply`另一端用`ParticleColor`的`A`->`Depth Fade->`Opacity`

![1702886021709](pics\1702886021709.png)

#### 新建Material Instance `MI_TraimSmoke`



#### 新建Niagara Emitter `NE_TrailSmokeEmitter`

用`Empty Template`

`SPRITE RENDERER`是一种只会正面对相机展示材料的平面->`Material`选择`MI_TrailSmoke`-> `SUB UV`的`Sub Image Size`改成`8*8`

`EMITTER UPDATE`可以配置每帧`Emitter`发生什么->旁边的+号`Add new Module`添加`Spawn Rate`->`SpawnRate`设置为70.0

`PARTICLE SPAWN`可以配置每次Spawn的时候发生什么->旁边的+号`Add new Module`添加`Set new or existing parameter directly`->+号`Set Specific Parameters`添加`SubImageIndex`->索引值右边有个`Edit value`选择`Random Range Float`设置为(0,63)

`PARTICLE UPDATE`可以设置每个更新帧粒子发生什么->旁边的+号`Add new Module`添加`Scale Sprite Size`->值右边有个`Edit value`选择`Vector2D From Float`->`Value`右边有个`Edit value`选择`Float from Curve`->`Add Key to Curve`设置一系列坐标点(0,0), (0.2,1.5), (0.7,0.2),(2,0)，用auto让曲线更平滑

`PARTICLE UPDATE`->`Add new Module`添加`Scale Color`->`Scale RGB`右边的`Edit Value`选择`Vector from Curve`分别为三`X/Y/ZCurve`设置坐标点(0.6,0.03)

`INITIALIZE PARTICLE`的`Sprite Size Mode`改成`Random Uniform`(7,14)，`Sprite Rotation Mode`改成`Random`，`Lifetime Mode`改成`Random`(2,2.5)



##### 复制`NE_TrailSmokeEmitter`改一改变成`NE_TrailFire`

复制一份`NE_TrailSmokeEmitter`命名为`NE_TrailFire`

修改`EMITTERUPDATE`的`SpawnRate`为75

`PARTICLE SPAWN`的`Lifetime Mode`改成`Direct Set`，`Lifetime`改成0.25，`Sprite Size Mode`改成(1,5)

`PARTICLE UPDATE` 的`Scale Sprite Size`的`Curve`的第二个节点改成(0.05,0.06)

`PARTICLE UPDATE` 的`Scale Color`的节点,只针对`XCurve`改成(0,0.85),(0.54,1.57),(0.65,0.6),(0.88,0.03)，`YCurve`改成(0,0.72),(0.32,0.03)，`ZCurve`改成(0,0.4),(0.14,0.02)



#### 新建Niagara System `NS_TrailSmoke`

Create Empty System

复制`NE_TrailSmokeEmitter`和`NE_TrailFire`粘贴到`NS_TrailSmoke`里

`NE_TrailSmokeEmitter`的`SpawnRate`改成150

`NE_TrailFire`的`Scale Sprite Size`的`Uniform Curve Scale`改成12，`Scale Color`的`Uniform Curve Scale`改成25





# Spawning Rocket Trails

## 在Rocket飞行的途中显示轨迹

要写代码的原因：Rocket命中时会走`Destroy`，连带着轨迹Niagara System一起会瞬间消失

### 在项目设置`Blaster.Build.cs`里添加`Niagara`模块

```cpp
PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "Niagara" });
```



### 修改`Projectile`里一些变量改成`protected`

用定时器延迟销毁会导致Rocket的爆炸需要在`OnHit`里立刻播放音效和特效，而不再走`Destroyed`

客户端也要执行`OnHit`回调，所以把`CollisionBox`也改下

```cpp
protected:
	UPROPERTY(EditAnywhere)
	UBoxComponent* CollisionBox;

	UPROPERTY(EditAnywhere)
	UParticleSystem* ImpactParticles;

	UPROPERTY(EditAnywhere)
	USoundCue* ImpactSound;
```



### 在`ProjectileRocket`里处理轨迹的保留

加个定时器触发的时候才销毁

`TrailSystem`用前面做的`NS_TrailSmoke`

`ProjectileLoop`用`RocketLauncher_InAirLoop_Cue`

`LoopingSoundAttenuation`用`RocketLoop_att`

```cpp
public:
	virtual void Destroyed() override;

protected:
	virtual void BeginPlay() override;

	UPROPERTY(EditAnywhere)
	UNiagaraSystem* TrailSystem;

	UPROPERTY()
	UNiagaraComponent* TrailSystemComponent;

	void DestroyTimerFinished();

	UPROPERTY(EditAnywhere)
    USoundCue* ProjectileLoop;

	UPROPERTY()
	UAudioComponent* ProjectileLoopComponent;
	
	UPROPERTY(EditAnywhere)
	USoundAttenuation* LoopingSoundAttenuation;

private:
	FTimerHandle DestroyTimer;

	UPROPERTY(EditAnywhere)
    float DetroyTime = 3.0f;
```



在`BeginPlay`播放`SpawnSystemAttached`和`SpawnSoundAttached`的`bAutoDestroy`设置为false，以满足上面说的延迟销毁需求

`OnHit`在Client也绑定，这样可以不用网络同步实现隐藏Mesh、播放音效等

流程变成`BeginPlay`开始播放飞行特效和音效->

`OnHit`的时候服务端处理伤害结算，服务端和客户端都播放命中特效音效、隐藏Mesh、取消碰撞盒碰撞、停止飞行特效和音效并设定定时器->

定时器触发执行销毁Actor

```cpp
#include "NiagaraFunctionLibrary.h"
#include "NiagaraComponent.h"
#include "Sound/SoundCue.h"
#include "Components/AudioComponent.h"
#include "Components/BoxComponent.h"

void AProjectileRocket::BeginPlay()
{
    Super::BeginPlay();
    
    if (!HasAuthority())
	{
		CollisionBox->OnComponentHit.AddDynamic(this, &ThisClass::OnHit);
	}
    
    if(TrailSystem)
    {
        TrailSystemComponent = UNiagaraFunctionLibrary::SpawnSystemAttached(
        	TrailSystem,
            GetRootComponent(),
            FName(),
            GetActorLocation(),
            GetActorRotation(),
            EAttachLocation::KeepWorldPosition,
            false
        );
    }
    
    if(ProjectileLoop && LoopingSoundAttenuation)
    {
        ProjectileLoopComponent = UGameplayStatics::SpawnSoundAttached(
        	ProjectileLoop,
            GetRootComponent(),
            FName(),
            GetActorLocation(),
            EAttachLocation::KeepWorldPosition,
            false,
            1.0f,
            1.0f,
            0.0f,
            LoopingSoundAttenuation,
            (USoundConcurrency*) nullptr,
            false
        );
    }
}

void AProjectileRocket::DestroyTimerFinished()
{
    Destroy();
}

void AProjectileRocket::Destroyed()
{
    
}
    
void AProjectileRocket::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)
{
    // ...
    if (FiringPawn && HasAuthority())
    {
        // ...
    }
    
    // Super::OnHit(HitComp, OtherActor, OtherComp, NormalImpulse, Hit);
    GetWorldTimerManager().SetTimer(
    	DestroyTimer,
        this,
        &ThisClass::DestroyTimerFinished,
        DetroyTime
    );
    
    if (ImpactParticles)
	{
		UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ImpactParticles, GetActorTransform());
	}

	if (ImpactSound)
	{
		UGameplayStatics::PlaySoundAtLocation(this, ImpactSound, GetActorLocation());
	}
    
    if(RocketMesh)
    {
        RocketMesh->SetVisibility(false);
    }
    
    if(CollisionBox)
    {
        CollisionBox->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    }
    
    if(TrailSystemComponent && TrailSystemComponent->GetSystemInstance())
    {
        TrailSystemComponent->GetSystemInstance()->Deactivate();
    }
    
    if(ProjectileLoopComponent && ProjectileLoopComponent->IsPlaying())
    {
        ProjectileLoopComponent->Stop();
    }
}
```



### 修改`RocketLauncher_InAirLoop_Cue`的设置

`Virtualization Mode`改成`Play when Silent`

`Volume Multiplier`改成0.25 降低循环的音量

`Wave Player`的`Looping`打开勾选，以便可以循环播放





# Rocket Movement Component

## 自定义移动组件管理火箭弹的移动

火箭命中发射者触发了`OnHit`，导致停止移动



### 自定义火箭弹移动组件`RocketMovementComponent`

继承自`ProjectileMovementComponent`



```cpp
protected:
	virtual EHandleBlockingHitResult HandleBlockingHit(const FHitResult& Hit, float TimeTick, const FVector& MoveDelta, float& SubTickTimeRemaining) override;

	virtual void HandleImpact(const FHitResult& Hit, float TimeSlice=0.f, const FVector& MoveDelta = FVector::ZeroVector) override;
```



```cpp
URocketMovementComponent::EHandleBlockingHitResult URocketMovementComponent::HandleBlockingHit(const FHitResult& Hit, float TimeTick, const FVector& MoveDelta, float& SubTickTimeRemaining)
{
    Super::HandleBlockingHit(Hit, TimeTick, MoveDelta,  SubTickTimeRemaining);
    
    return EHandleBlockingHitResult::AdvanceNextSubstep;
}

void URocketMovementComponent::HandleImpact(const FHitResult& Hit, float TimeSlice, const FVector& MoveDelta)
{
    // Rocket should not stop; only explode when their CollisionBox detects a hit.
}
```



### 注释掉`Projectile`里初始化`ProjectileMovementComponent`

具体的子类如果有其对应的`MovementComponent`则在子类自己的构造函数里初始化

```cpp
protected:
	UPROPERTY(EditAnywhere)
	UProjectileMovementComponent* ProjectileMovementComponent;
```



```cpp
AProjectile::AProjectile()
{
    // ...
    /*
    ProjectileMovementComponent = CreateDefaultSubobject<UProjectileMovementComponent>(TEXT("ProjectileMovementComponent"));
	ProjectileMovementComponent->bRotationFollowsVelocity = true;
	*/
}
```



### 在`ProjectileBullet`里修改`MovementComponent`

并设置为网络同步

```cpp
public:
	AProjectileBullet();
```



```cpp
#include "GameFramework/ProjectileMovementComponent.h"

AProjectileBullet::AProjectileBullet()
{
	ProjectileMovementComponent = CreateDefaultSubobject<UProjectileMovementComponent>(TEXT("ProjectileMovementComponent"));
	ProjectileMovementComponent->bRotationFollowsVelocity = true;
    ProjectileMovementComponent->SetIsReplicated(true);
}
```



### 在`ProjectileRocket`里子弹命中发射者的问题

```cpp
protected:
	UPROPERTY(VisibleAnywhere)
	URocketMovementComponent* RocketMovementComponent;
```



```cpp
#include "RocketMovementComponent.h"

AProjectileRocket::AProjectileRocket()
{
    // ...
    RocketMovementComponent = CreateDefaultSubobject<URocketMovementComponent>(TEXT("RocketMovementComponent"));
	RocketMovementComponent->bRotationFollowsVelocity = true;
    RocketMovementComponent->SetIsReplicated(true);
}

void AProjectileRocket::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)
{
    if(OtherActor == GetOwner())
    {
        // UE_LOG(LogTemp, Warning, TEXT("Hit self."));
        return;
    }
    
     // ...    
}
```



### 在`BP_ProjectileRocket`里配置

`Initial Speed`和`Max Speed`改成1500

`Projectile Gravity Scale`改成0





## 修复播放`Reload Montage`的报错

### 在`BlasterCharacter`里添加`Rocket`类型

```cpp
void ABlasterCharacter::PlayReloadMontage()
{
    // ...
    switch (Combat->EquippedWeapon->GetWeaponType())
		{
		case EWeaponType::EWT_AssaultRifle:
		{
			SectionName = FName("Rifle");
			break;
		}
		case EWeaponType::EWT_RocketLauncher:
		{
			SectionName = FName("Rifle");
			break;
		}
	}
}
```





## 修复`WeaponMovement`没有网络同步的问题

### 在`Weapon`里处理

```cpp
AWeapon::AWeapon()
{
    // ...
    SetReplicateMovement(true);
}
```



### 检查每种武器的蓝图是否覆盖了`ReplicateMovement`





# Hit Scan Weapons

## 增加一种用`Line Trace`的方式而不是Projectile的OnHit来查找命中者的武器

### 新建一个`HitScanWeapon`

继承自`Weapon`



```cpp
public:
	virtual void Fire(const FVector& HitTarget) override;

private:
	UPROPERTY(EditAnywhere)
    float Damage = 20.0f;

	UPROPERTY(EditAnywhere)
    UParticleSystem* ImpactParticles;
```



```cpp
#include "Engine/SkeletalMeshSocket.h"
#include "Blaster/Character/BlasterCharacter.h"
#include "Kismet/GameplayStatics.h"

void AHitScanWeapon::Fire(const FVector& HitTarget)
{
    Super::Fire(HitTarget);
    
    APawn* OwnerPawn = Cast<APawn>(GetOwner());
    if(!OwnerPawn)
    {
        return;
    }
    
    AController* InstigatorController = OwnerPawn->GetController();
    if(!InstigatorController)
    {
        return;
    }
    
    const USkeletalMeshSocket* MuzzleFlashSocket = GetWeaponMesh()->GetSocketByName("MuzzleFlash");
    if(MuzzleFlashSocket)
    {
        FTransform SocketTransform = MuzzleFlashSocket->GetSocketTransform(GetWeaponMesh());
        FVector Start = SocketTransform.GetLocation();
        FVector End = Start + (HitTarget - Start) * 1.25f;
        
        FHitResult FireHit;
        UWorld* World = GetWorld();
        if(World)
        {
            World->LineTraceSingleByChannel(
            	FireHit,
                Start,
                End,
                ECollisionChannel::ECC_Visibility
            );
            
            if(FireHit.bBlockingHit)
            {
                ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(FireHit.GetActor());
                if(BlasterCharacter && HasAuthority())
                {
                    UGameplayStatics::ApplyDamage(
                    	BlasterCharacter,
                        Damage,
                        InstigatorController,
                        this,
                        UDamageType::StaticClass()
                    );
                }
                
                if(ImpactParticles)
                {
                    UGameplayStatics::SpawnEmitterAtLocation(
                    	World,
                    	ImpactParticles,
                        FireHit.ImpactPoint,
                        FireHit.ImpactNormal.Rotation()
                    );
                }
            }
        }
    }
}
```



### 在`WeaponType`添加新的手枪类型

```cpp
UENUM(BlueprintType)
enum class EWeaponType : uint8
{
	EWT_AssaultRifle UMETA(DisplayName = "Assault Rifle"),
    EWT_RocketLauncher UMETA(DisplayName = "Rocket Launcher"),
    EWT_Pistol UMETA(DisplayName = "Pistol"),
	EWT_MAX UMETA(DisplayName = "DefaultMAX"),
};
```



### 在`BlasterCharacter`更新换弹Montage的Section

```cpp
void ABlasterCharacter::PlayReloadMontage()
{
    // ...
    switch (Combat->EquippedWeapon->GetWeaponType())
		{
		case EWeaponType::EWT_AssaultRifle:
		{
			SectionName = FName("Rifle");
			break;
		}
		case EWeaponType::EWT_RocketLauncher:
		{
			SectionName = FName("Rifle");
			break;
		}
        case EWeaponType::EWT_Pistol:
		{
			SectionName = FName("Rifle");
			break;
		}
	}
}
```



### 在`CombatComponent`初始化手枪类型的弹药



```cpp
private:
	UPROPERTY(EditAnywhere)
	int32 StartingPistolAmmo = 30;
```



```cpp
void UCombatComponent::InitializeCarriedAmmo()
{
	CarriedAmmoMap.Emplace(EWeaponType::EWT_AssaultRifle, StartingARAmmo);
    CarriedAmmoMap.Emplace(EWeaponType::EWT_RocketLauncher, StartingRocketAmmo);
    CarriedAmmoMap.Emplace(EWeaponType::EWT_Pistol, StartingPistolAmmo);
}
```



### 制作新的弹壳材质 `M_Pistol_Ammo`

复制一份`M_Pistol_01`命名为`M_Pistol_Ammo`

`Parent`用之前做的`M_Ammo`



### 创建新的弹壳蓝图 `BP_PistolCasing`

派生自`Casing`

`Skeletal Mesh`选择`PistolA_Ammo`

`Element 0`选择`M_Pistol_Ammo`

`Shell Ejection Impulse`改成5

`Shell Sound`选择`Shells_Cue`



### 修改`Pistols_A`的`AmmoEject`以让弹壳朝向正确的方向抛出

向X轴负方向移动，以使得弹壳是从正确的Location抛出

右击`AmmoEject`->`Add Preview Asset`选择`PistolA_Ammo`

旋转使得Z轴朝向枪管朝向，X轴朝向右侧



### 创建手枪蓝图 `BP_Pistol`

派生自`HitScanWeapon`

`Skeletal Mesh`选择`Pistols_A`

移动`Area Sphere`使其球心在武器Mesh中心，设置`Sphere Radius`使其包裹整个Mesh

`PickupWidget`里的`Space`改成`Screen`,`WidgetClass`为`WBP_PickupWidget`，勾选上`Draw at Desired Size`,在viewport里把PickupWidget往上调整一下让文字显示在武器上方

`Impact Particles`用`P_Impact_Metal_Medium_01`

`Crosshairs`选和突击步枪一样的对应的`Crosshair_XXX`

`Zoomed FOV`改成45，`Zoom Interp Speed`改成20

`Equip Sound`用`Pistol_Lower_Cue`

`Casing Class`用`BP_PistolCasing`

`Ammo`和`MagCapacity`改成15 

`WeaponType`用`Pistol`

`Fire Delay`改成0.1

`Automatic`取消勾选

`Fire Animation`选`Fire_Pistol_W`



### 调整`Pistols_A`的`LeftHandSocket`使得动画的左手位置正确







# Beam Particles

## 给子弹加一个和前面做的火箭弹类似的尾迹

### 获取Assets

`M_Beam`里的`Texture Sample`要改一下`Texture`改成`BeamTextureThin`

`P_SmokeTrail`的`Required`的`Material`选择`M_Beam`



### 在`HitScanWeapon`处理尾迹



```cpp
private:
	UPROPERTY(EditAnywhere)
	UParticleSystem* BeamParicles;
```



`InstigatorController`在`SimulatedProxy`上是拿不到的

```cpp
#include "Particles/ParticleSystemComponent.h"

void AHitScanWeapon::Fire(const FVector& HitTarget)
{
    /*
    if (!InstigatorController)
	{
		return;
	}
	*/
    // ...
    FVector BeamEnd = End;
    if (FireHit.bBlockingHit)
    {
        BeamEnd = FireHit.ImpactPoint;
        if (BlasterCharacter && HasAuthority() && InstigatorController)
        {
        	// ...
        }
        // ...
    }
    
    if(BeamParicles)
    {
        UParticleSystemComponent* Beam = UGameplayStatics::SpawnEmitterAtLocation(
        	World,
            BeamParicles,
            SocketTransform
        );
        
        if(Beam)
        {
            Beam->SetVectorParameter(FName("Target"), BeamEnd);
        }
    }
    
    // ...
}
```







# Submachine Gun

## 制作一个BP_SMG

### 找点Assets

Epic市场有个免费的`FPS Weapon Bundle`

### 在`SK_SMG11_Nostock_Y`上加一些socket

在`b_gun_Root`加一个`LeftHandSocket`用于左手，调试修改位置

在`b_gun_muzzleflash`加一个`MuzzleFlash`用于开火闪光，调试修改旋转开火的闪光朝向正确

在`b_gun_Root`加一个`AmmoEject`，移动到正确的位置并旋转让x轴朝向右方，z轴朝向枪口前方，`Preview Asset`选择`PistolA_Ammo`



### 在`WeaponType`添加新的手枪类型

```cpp
UENUM(BlueprintType)
enum class EWeaponType : uint8
{
	EWT_AssaultRifle UMETA(DisplayName = "Assault Rifle"),
    EWT_RocketLauncher UMETA(DisplayName = "Rocket Launcher"),
    EWT_Pistol UMETA(DisplayName = "Pistol"),
    EWT_SubmachineGun UMETA(DisplayName = "Submachine Gun"),
	EWT_MAX UMETA(DisplayName = "DefaultMAX"),
};
```



### 在`BlasterCharacter`更新换弹Montage的Section

```cpp
void ABlasterCharacter::PlayReloadMontage()
{
    // ...
    switch (Combat->EquippedWeapon->GetWeaponType())
		{
		case EWeaponType::EWT_AssaultRifle:
		{
			SectionName = FName("Rifle");
			break;
		}
		case EWeaponType::EWT_RocketLauncher:
		{
			SectionName = FName("Rifle");
			break;
		}
        case EWeaponType::EWT_Pistol:
		{
			SectionName = FName("Rifle");
			break;
		}
        case EWeaponType::EWT_SubmachineGun:
		{
			SectionName = FName("Rifle");
			break;
		}
	}
}
```



### 在`CombatComponent`初始化手枪类型的弹药



```cpp
private:
	UPROPERTY(EditAnywhere)
	int32 StartingSMGAmmo = 40;
```



```cpp
void UCombatComponent::InitializeCarriedAmmo()
{
	CarriedAmmoMap.Emplace(EWeaponType::EWT_AssaultRifle, StartingARAmmo);
    CarriedAmmoMap.Emplace(EWeaponType::EWT_RocketLauncher, StartingRocketAmmo);
    CarriedAmmoMap.Emplace(EWeaponType::EWT_Pistol, StartingPistolAmmo);
    CarriedAmmoMap.Emplace(EWeaponType::EWT_SubmachineGun, StartingSMGAmmo);
}
```



### 在`HitScanWeapon`添加开火特效和音效

```cpp
private:
	UPROPERTY(EditAnywhere)
    UParticleSystem* MuzzleFlash;

	UPROPERTY(EditAnywhere)
    USoundCue* FireSound;

	UPROPERTY(EditAnywhere)
    USoundCue* HitSound;
```



```cpp
#include "Sound/SoundCue.h"

void AHitScanWeapon::Fire(const FVector& HitTarget)
{
    // ...
    if (FireHit.bBlockingHit)
    {
        // ...
        if(HitSound)
        {
            UGameplayStatics::PlaySoundAtLocation(
                this,
                HitSound,
                FireHit.ImpactPoint
            );
        }
    }
    // ...
    
    if(MuzzleFlash)
    {
        UGameplayStatics::SpawnEmitterAtLocation(
            World,
            MuzzleFlash,
            SocketTransform
        );
    }

    if(FireSound)
    {
        UGameplayStatics::PlaySoundAtLocation(
        	this,
            FireSound,
            GetActorLocation()
        );
    }
}
```



### 创建`BP_SubmachineGun`

派生自`HitScanWeapon`

`Skeletal Mesh`选`SK_SMG11_Nostock_Y`

移动`Area Sphere`使其球心在武器Mesh中心，设置`Sphere Radius`使其包裹整个Mesh

`PickupWidget`里的`Space`改成`Screen`,`WidgetClass`为`WBP_PickupWidget`，勾选上`Draw at Desired Size`,在viewport里把PickupWidget往上调整一下让文字显示在武器上方

`Impact Particles`用`P_Impact_Metal_Large_01`

`Beam Particles` 用`P_SmokeTrail`

`MuzzleFlash`用`P_Pistol_MuzzleFlash_01`

`FireSound`用`SMG_Cue`

`HitSound`用`Rifle_ImpactSurface_Cue`

`Crosshairs`选和突击步枪一样的对应的`Crosshair_XXX`

`Zoomed FOV`改成45，`Zoom Interp Speed`改成20

`Equip Sound`用`Pistol_ReloadInsert_Cue`

`Casing Class`用`BP_PistolCasing`

`Ammo`和`MagCapacity`改成20 

`WeaponType`用`Submachine Gun`

`Fire Delay`改成0.1

`Automatic`勾选







# Strap Physics

## 让SMG枪上的带子有物理效果

### 创建物理资产`SMG_PhyAt_Strap`

选中`SK_SMG11_Nostock_Y`右击`Create`->`Physics Asset`->`Create And Assign`勾选上`Create Body for All Bones`

选中`b_gun_Root`->`Add Shape`->`Add Box`用三个Box分别覆盖弹匣、握把、枪膛，用一个Capsule覆盖枪口->删除用不上的胶囊体只保留带子上的

调整枪带上的胶囊体让他们保持水平以及彼此不要重叠，然后全部选中`b_gun_rem02`到`b_gun_rem06`的胶囊体`Physics Type`改成`Simulated`，打开`Mass`并设定为1，`Linear Damping`改成7，`Angular Damping`改成7



### 在`Weapon`里启用物理模拟

```cpp
void AWeapon::SetWeaponState(EWeaponState State)
{
	// ...
    case EWeaponState::EWS_Equipped:
    {
        // ...
        if(WeaponType == EWeaponType::EWT_SubmachineGun)
        {
            WeaponMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
            WeaponMesh->SetEnableGravity(true);
            WeaponMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);
        }
        break;
    }
    case EWeaponState::EWS_Dropped:
    {
        // ...
        WeaponMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);
	WeaponMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Ignore);
        WeaponMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_Camera, ECollisionResponse::ECR_Ignore);
        break;
    }
}

void AWeapon::OnRep_WeaponState()
{
    // ...
    case EWeaponState::EWS_Equipped:
    {
        // ...
        if(WeaponType == EWeaponType::EWT_SubmachineGun)
        {
            WeaponMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
            WeaponMesh->SetEnableGravity(true);
            WeaponMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);
        }
    }
    case EWeaponState::EWS_Dropped:
    {
        // ...
        WeaponMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);
	WeaponMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Ignore);
        WeaponMesh->SetCollisionResponseToChannel(ECollisionChannel::ECC_Camera, ECollisionResponse::ECR_Ignore);
        break;
    }
}
```







# Shotgun

## 制作霰弹枪

### 在`HitScanWeapon`里处理随机散布

散布是以起始点+`DistanceToSphere`的终点为圆心`SphereRadius`为半径的一个球内的若干随机位置

```cpp
protected:
	FVector TraceEndWithScatter(const FVector& TraceStart, const FVector& HitTarget);

private:
	UPROPERTY(EditAnywhere, Category = "Weapon Scatter")
    float DistanceToSphere = 800.0f;

	UPROPERTY(EditAnywhere, Category = "Weapon Scatter")
    float SphereRadius = 75.0f;

	UPROPERTY(EditAnywhere, Category = "Weapon Scatter")
    bool bUseScatter = false;

	UPROPERTY(EditAnywhere)
	float TraceLength{ 80000.0f };
```



```cpp
#include "DrawDebugHelpers.h"
#include "Kismet/KismetMathLibrary.h"

FVector AHitScanWeapon::TraceEndWithScatter(const FVector& TraceStart, const FVector& HitTarget)
{
    FVector ToTargetNorlmalized = (HitTarget - TraceStart).GetSafeNormal();
    FVector SphereCenter = TraceStart + ToTargetNorlmalized * DistanceToSphere;
    FVector RandVec = UKismetMathLibrary::RandomUnitVector() * FMath::FRandRange(0.0f, SphereRadius);
    FVector EndLoc = SphereCenter + RandVec;
    FVector ToEndLoc = EndLoc - TraceStart;
    FVector ReturnVec = FVector(TraceStart + ToEndLoc * TraceLength / ToEndLoc.Size());
                                
    DrawDebugSphere(GetWorld(), SphereCenter, SphereRadius, 12, FColor::Red, true);
    DrawDebugSphere(GetWorld(), EndLoc, 4.0f, 12, FColor::Orange, true);
    DrawDebugLine(GetWorld(), TraceStart, ReturnVec, FColor::Cyan, true);
    
    return ReturnVec;
}
```



### 新建`Shotgun`类

继承自`HitScanWeapon`

```cpp
public:
	virtual void Fire(const FVector& HitTarget) override;

private:
	UPROPERTY(EditAnywhere, Category = "Weapon Scatter")
   	int32 NumberOfPellets = 10;
```



```cpp
#include "Engine/SkeletalMeshSocket.h"
#include "Blaster/Character/BlasterCharacter.h"
#include "Kismet/GameplayStatics.h"
#include "Particles/ParticleSystemComponent.h"
#include "Sound/SoundCue.h"


void AShotgun::Fire(const FVector& HitTarget)
{
    AWeapon::Fire(HitTarget);
    
	APawn* OwnerPawn = Cast<APawn>(GetOwner());
	if (!OwnerPawn)
	{
		return;
	}

	const USkeletalMeshSocket* MuzzleFlashSocket = GetWeaponMesh()->GetSocketByName("MuzzleFlash");
	if (!MuzzleFlashSocket)
	{
		return;
	}

	FTransform SocketTransform = MuzzleFlashSocket->GetSocketTransform(GetWeaponMesh());
	FVector Start = SocketTransform.GetLocation();
    for(uint32 i = 0; i < NumberOfPellets; ++i)
    {
        FVector End = TraceEndWithScatter(Start, HitTarget);
        
    }	
}
```



### 在`WeaponType`添加新的霰弹枪类型

```cpp
UENUM(BlueprintType)
enum class EWeaponType : uint8
{
	EWT_AssaultRifle UMETA(DisplayName = "Assault Rifle"),
    EWT_RocketLauncher UMETA(DisplayName = "Rocket Launcher"),
    EWT_Pistol UMETA(DisplayName = "Pistol"),
    EWT_SubmachineGun UMETA(DisplayName = "Submachine Gun"),
    EWT_Shotgun UMETA(DisplayName = "Shotgun"),
	EWT_MAX UMETA(DisplayName = "DefaultMAX"),
};
```



### 在`BlasterCharacter`更新换弹Montage的Section

```cpp
void ABlasterCharacter::PlayReloadMontage()
{
    // ...
    switch (Combat->EquippedWeapon->GetWeaponType())
		{
		case EWeaponType::EWT_AssaultRifle:
		{
			SectionName = FName("Rifle");
			break;
		}
		case EWeaponType::EWT_RocketLauncher:
		{
			SectionName = FName("Rifle");
			break;
		}
        case EWeaponType::EWT_Pistol:
		{
			SectionName = FName("Rifle");
			break;
		}
        case EWeaponType::EWT_SubmachineGun:
		{
			SectionName = FName("Rifle");
			break;
		}
        case EWeaponType::EWT_Shotgun:
		{
			SectionName = FName("Rifle");
			break;
		}
	}
}
```



### 在`CombatComponent`初始化霰弹枪类型的弹药



```cpp
private:
	UPROPERTY(EditAnywhere)
	int32 StartingShotgunAmmo = 10;
```



```cpp
void UCombatComponent::InitializeCarriedAmmo()
{
	// ...
    CarriedAmmoMap.Emplace(EWeaponType::EWT_Shotgun, StartingShotgunAmmo);
}
```



### 创建霰弹枪弹壳`BP_ShotgunCasing`

派生自`Casing`

`Mesh`用`ShotgunA_Ammo`

`Shell Sound`用`Shells_Cue`



### 在`Shotgun_A`里配置Socket

`LeftHandSocket`放在`Glip_Bone`上使得左手可以和动画一起移动，边调试边移动使左手在正确的位置

`AmmoEject`调整至Z轴朝向枪管前方，X轴朝向右侧，`Preview Asset`用`ShotgunA_Ammo`



### 在`Fire_Shotgun_W`里修改动画

前移`Muzzle Flash`到第0帧和`Reload`移动到第20帧一些使其表现更好

如果要使其更有张力可以在第0帧和最后一帧`Add Key`，然后在中间将Clip_Bone向后移动一些再`Add Key`，最后`Create Asset`



### 创建`BP_Shotgun`

派生自`Shotgun`

`Skeletal Mesh`选`Shotgun_A`

移动`Area Sphere`使其球心在武器Mesh中心，设置`Sphere Radius`使其包裹整个Mesh

`PickupWidget`里的`Space`改成`Screen`,`WidgetClass`为`WBP_PickupWidget`，勾选上`Draw at Desired Size`,在viewport里把PickupWidget往上调整一下让文字显示在武器上方

勾选上`Use Scatter`

`Impact Particles`用`P_Impact_Metal_Small_01`

`Beam Particles` 用`P_SmokeTrail`

`HitSound`用`Shotgun_ImpactSurface_Cue`

`Crosshairs Center`用`shotgun_small_center` 

`Crosshairs Left`用`shotgun_small_left`

`Crosshairs Right`用`shotgun_small_right`

`Zoomed FOV`改成55，`Zoom Interp Speed`改成20

`Equip Sound`用`Shotgun_Lower_Cue`

`Casing Class`用`BP_ShotgunCasing`

`Ammo`和`MagCapacity`改成5

`WeaponType`用`Shotgun`

`Fire Delay`改成1.33

`Automatic`取消勾选

`Fire Animation`用`Fire_Shotgun_W`





# Weapon Scatter

## 处理所有HitScanWeapon的Scatter

### 处理`HitScanWeapon`的一些Fire效果

因为Shotgun要用一些变量，所以把他们从private挪到protected里

```cpp
protected:
	void WeaponTraceHit(const FVector& TraceStart, const FVector& HitTarget, FHitResult& OutHit);

	UPROPERTY(EditAnywhere)
	float Damage = 20.0f;

	UPROPERTY(EditAnywhere)
	UParticleSystem* ImpactParticles;

	UPROPERTY(EditAnywhere)
	USoundCue* HitSound;

	UPROPERTY(EditAnywhere)
	UParticleSystem* MuzzleFlash;

	UPROPERTY(EditAnywhere)
	USoundCue* FireSound;
```



`WeaponTraceHit`除了处理落点，也顺便处理尾焰Beam

`Fire`用`WeaponTraceHit`的返回值作为落点，计算伤害以及各种显示的播放

```cpp
void AHitScanWeapon::WeaponTraceHit(const FVector& TraceStart, const FVector& HitTarget, FHitResult& OutHit)
{
    UWorld* World = GetWorld();
    if (!World)
	{
		return;
	}

    FVector End = bUseScatter ? TraceEndWithScatter(TraceStart, HitTarget) : TraceStart + (HitTarget - TraceStart) * 1.25f;
    
    World->LineTraceSingleByChannel(
		OutHit,
		TraceStart,
		End,
		ECollisionChannel::ECC_Visibility
	);
    
    FVector BeamEnd = End;
    if (OutHit.bBlockingHit)
    {
        BeamEnd = OutHit.ImpactPoint;
        
        if (BeamParicles)
        {
            UParticleSystemComponent* Beam = UGameplayStatics::SpawnEmitterAtLocation(
                World,
                BeamParicles,
                TraceStart,
                FRotator::ZeroRotator,
                true
            );

            if (Beam)
            {
                Beam->SetVectorParameter(FName("Target"), BeamEnd);
            }
        }
    }
}

void AHitScanWeapon::Fire(const FVector& HitTarget)
{
	// ...
	FVector Start = SocketTransform.GetLocation();
	FHitResult FireHit;
    WeaponTraceHit(Start, HitTarget, FireHit);
    
	/*
    if (BeamParicles)
    {
    	// ...
    }
    */
	// ...
}
```



### 处理Shotgun的散射

```cpp
void AShotgun::Fire(const FVector& HitTarget)
{
	AWeapon::Fire(HitTarget);

	APawn* OwnerPawn = Cast<APawn>(GetOwner());
	if (!OwnerPawn)
	{
		return;
	}

	const USkeletalMeshSocket* MuzzleFlashSocket = GetWeaponMesh()->GetSocketByName("MuzzleFlash");
	if (!MuzzleFlashSocket)
	{
		return;
	}

	FTransform SocketTransform = MuzzleFlashSocket->GetSocketTransform(GetWeaponMesh());
	FVector Start = SocketTransform.GetLocation();
    
	AController* InstigatorController = OwnerPawn->GetController();
    TMap<ABlasterCharacter*, uint32> HitMap;
	for (int32 i = 0; i < NumberOfPellets; ++i)
	{
		FHitResult FireHit;
    	WeaponTraceHit(Start, HitTarget, FireHit);
        
        ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(FireHit.GetActor());
		if (BlasterCharacter && HasAuthority() && InstigatorController)
		{
            if(HitMap.Contains(BlasterCharacter))
            {
                HitMap[BlasterCharacter]++;
            }
            else
            {
                HitMap.Emplace(BlasterCharacter, 1);
            }
            
		}
        
        if (ImpactParticles)
		{
			UGameplayStatics::SpawnEmitterAtLocation(
				GetWorld(),
				ImpactParticles,
				FireHit.ImpactPoint,
				FireHit.ImpactNormal.Rotation()
			);
		}

		if (HitSound)
		{
			UGameplayStatics::PlaySoundAtLocation(
				this,
				HitSound,
				FireHit.ImpactPoint,
                0.5f,
                FMath::FRandRange(-0.5f, 0.5f)
			);
		}
	}
    
    for(auto HitPair : HitMap)
    {
        if (HitPair.Key && HasAuthority() && InstigatorController)
		{
			UGameplayStatics::ApplyDamage(
				HitPair.Key,
				Damage * HitPair.Value,
				InstigatorController,
				this,
				UDamageType::StaticClass()
			);
		}
    }
    
    if (MuzzleFlash)
	{
		UGameplayStatics::SpawnEmitterAtLocation(
			GetWorld(),
			MuzzleFlash,
			SocketTransform
		);
	}

	if (FireSound)
	{
		UGameplayStatics::PlaySoundAtLocation(
			this,
			FireSound,
			GetActorLocation()
		);
	}
}
```



### 配置蓝图里的`HitScanWeapons`

`BP_Pistol`保持不变，手枪仍然保持其准确性

`BP_SubmachineGun`打开Scatter，散布半径改小一点

`BP_Shotgun`打开Scatter，调低单颗子弹的伤害





# Sniper Rifle

## 制作狙击枪

### 在`WeaponType`添加新的狙击枪类型

```cpp
UENUM(BlueprintType)
enum class EWeaponType : uint8
{
	EWT_AssaultRifle UMETA(DisplayName = "Assault Rifle"),
    EWT_RocketLauncher UMETA(DisplayName = "Rocket Launcher"),
    EWT_Pistol UMETA(DisplayName = "Pistol"),
    EWT_SubmachineGun UMETA(DisplayName = "Submachine Gun"),
    EWT_Shotgun UMETA(DisplayName = "Shotgun"),
    EWT_SniperRifle UMETA(DisplayName = "Sniper Rifle"),
	EWT_MAX UMETA(DisplayName = "DefaultMAX"),
};
```



### 在`BlasterCharacter`更新换弹Montage的Section

```cpp
void ABlasterCharacter::PlayReloadMontage()
{
    // ...
    switch (Combat->EquippedWeapon->GetWeaponType())
		{
		// ...
        case EWeaponType::EWT_SniperRifle:
		{
			SectionName = FName("Rifle");
			break;
		}
	}
}
```



### 在`CombatComponent`初始化狙击枪类型的弹药



```cpp
private:
	UPROPERTY(EditAnywhere)
	int32 StartingSniperRifleAmmo = 10;
```



```cpp
void UCombatComponent::InitializeCarriedAmmo()
{
	// ...
    CarriedAmmoMap.Emplace(EWeaponType::EWT_SniperRifle, StartingSniperRifleAmmo);
}
```



### 给`Sniper_Rifle_A`添加socket

添加`LeftHandSocket` 调试并修改位置使左手放在合适的位置

`AmmoEject`调整方向并添加预览Asset



### 制作`BP_SniperRifle`

继承自`HitScanWeapon`

`Skeletal Mesh`选`Sniper_Rifle_A`

移动`Area Sphere`使其球心在武器Mesh中心，设置`Sphere Radius`使其包裹整个Mesh

`PickupWidget`里的`Space`改成`Screen`,`WidgetClass`为`WBP_PickupWidget`，勾选上`Draw at Desired Size`,在viewport里把PickupWidget往上调整一下让文字显示在武器上方

`Impact Particles`用`P_Impact_Metal_Large_01`

`HitSound`用`SniperRifle_ImpactSurface_Cue`

`Damage` 改成100

`Beam Particles` 用`P_SmokeTrail`

`Crosshairs`用和`AssaultRifle`一样的`Crosshair_XXX`

`Zoomed FOV`改成8，`Zoom Interp Speed`改成10

`Equip Sound`用`SniperRifle_Lower_Cue`

`Casing Class`用`BP_Casing`

`Ammo`和`MagCapacity`改成1

`WeaponType`用`Sniper Rifle`

`Fire Delay`改成1.4

`Automatic`取消勾选

`Fire Animation`用`Fire_SniperRifle_W`





# Sniper Scope

## 加个狙击镜的widget

### 制作`WBP_SniperScope`

加两个Image进去，分别命名为`ScopeOverlay`和`Background`

`ScopeOverlay`锚点放在中心,`Position`设为(0,0)，`Size`设置为(1920,1080)，`Alignment`设置为(0.5, 0.5)，`Brush`的`Image`选择`SniperScopeNoBG`

`Background`锚点放在中心,`Position`设为(16.9, -0.79)，`Size`设置为(3087, 1735)，`Alignment`设置为(0.5, 0.5)，`Brush`的`Image`选择`BlkBG1920x1080`

然后在Widget里点击`Add Animation`添加一个动画命名为`ScopeZoomIn`，`Add Track`选择`Background`，`Background`的`Add Track`选择`Render Opacity` 值填0->将时间戳往后移动到0.25秒把`Render Opacity` 的值设置为1

`Add Track`选择`ScopeOverlay`，`Background`的`Add Track`选择`Transform` 的`Scale`值填(0, 0)->将时间戳往后移动到0.2秒把`Transform` 的`Scale`值设置为(1, 1)



### 在`BlasterCharacter`里添加显示`WBP_SniperScope`的蓝图可实现函数

```cpp
public:
	UFUNCTION(BlueprintImplementableEvent)
	void ShowSniperScopeWidget(bool bShowScope);
```



```cpp
void ABlasterCharacter::MulticastElim_Implementation()
{
	// ...
    bool bHideSniperScope = IsLocallyControlled() && 
        Combat && 
        Combat->bIsAiming && 
        Combat->EquippedWeapon && 
        Combat->EquippedWeapon->GetWeaponType() == EWeaponType::EWT_SniperRifle;
    if(bHideSniperScope)
    {
        ShowSniperScopeWidget(false);
    }
}
```



### 在`BP_BlasterCharacter`里制作函数

`Event Show Sniper Scope Widget`->`SniperScopeWidget`是否`IsValid`

不存在的话->`Create Widget`选择`WBP_SniperScope`->把`Return Value`右击选择`Promote to Variable`命名为`SniperScopeWidget`->`Add to Viewport`

存在的话`Show Scope`->`Branch`

![1702987374061](pics\1702987374061.png)

​	如果为True，`SniperScopeWidget`是否`IsValid`如果是合法的话->`SniperScopeWidget`的`Get ScopeZoomIn`->`Play Animation`->`Play Sound 2D`选择`SniperRifle_ZoomIn_Cue`

​	如果False，`SniperScopeWidget`是否`IsValid`如果是合法的话->`SniperScopeWidget`的`Get ScopeZoomIn`->`Play Animation`的`Play Mode`选择`Reverse`->`Play Sound 2D`选择`SniperRifle_ZoomOut_Cue`

![1702987632017](pics\1702987632017.png)



### 在`CombatComponent`里调用`ShowSniperScopeWidget`

```cpp
void UCombatComponent::SetAiming(bool bAiming)
{
    if(!Character || !EquippedWeapon)
    {
        return;
    }
    
	bIsAiming = bAiming;
	ServerSetAiming(bAiming);

	Character->GetCharacterMovement()->MaxWalkSpeed = bAiming ? AimWalkSpeed : BaseWalkSpeed;
	
    if(Character->IsLocallyControlled() && EquippedWeapon->GetWeaponType() == EWeaponType::EWT_SniperRifle)
    {
        Character->ShowSniperScopeWidget(bIsAiming);
    }
}
```





# Grenade Launcher

## 新增一种榴弹发射器

### 在`WeaponType`添加新的榴弹发射器类型

```cpp
UENUM(BlueprintType)
enum class EWeaponType : uint8
{
	// ...
    EWT_GrenadeLauncher UMETA(DisplayName = "Grenade Launcher"),
	EWT_MAX UMETA(DisplayName = "DefaultMAX"),
};
```



### 在`BlasterCharacter`更新换弹Montage的Section

```cpp
void ABlasterCharacter::PlayReloadMontage()
{
    // ...
    switch (Combat->EquippedWeapon->GetWeaponType())
		{
		// ...
        case EWeaponType::EWT_GrenadeLauncher:
		{
			SectionName = FName("Rifle");
			break;
		}
	}
}
```



### 在`CombatComponent`初始化榴弹发射器类型的弹药



```cpp
private:
	UPROPERTY(EditAnywhere)
	int32 StartingGrenadeLauncherAmmo = 8;
```



```cpp
void UCombatComponent::InitializeCarriedAmmo()
{
	// ...
    CarriedAmmoMap.Emplace(EWeaponType::EWT_GrenadeLauncher, StartingGrenadeLauncherAmmo);
}
```



### 给`Grenade_Launcher_A`添加socket

添加`LeftHandSocket` 调试并修改位置使左手放在合适的位置



### 制作`BP_GrenadeLauncher`

继承自`ProjectileWeapon`

`Skeletal Mesh`选`Grenade_Launcher_A`

移动`Area Sphere`使其球心在武器Mesh中心，设置`Sphere Radius`使其包裹整个Mesh

`PickupWidget`里的`Space`改成`Screen`,`WidgetClass`为`WBP_PickupWidget`，勾选上`Draw at Desired Size`,在viewport里把PickupWidget往上调整一下让文字显示在武器上方

`Crosshairs`用和`Shotgun`一样的`shotgun_small_XXX`

`Zoomed FOV`改成60，`Zoom Interp Speed`改成20

`Equip Sound`用`GrenadeLauncher_Lower_Cue`

`Ammo`和`MagCapacity`改成4

`WeaponType`用`Grenade Launcher`

`Fire Delay`改成1

`Automatic`取消勾选

`Fire Animation`用`Fire_GrenadeLauncher_W`





# Projectile Grenades

## 制作榴弹

和火箭弹有一些类似的地方，所以可以把火箭弹的一些内容挪到Projectile里然后两个一起继承

### 把一些代码从`ProjectileRocket`放到`Projectile`里

`NiagaraSystem`、`Destroy`的定时器、Mesh

```cpp
protected:
	UPROPERTY(EditAnywhere)
	UNiagaraSystem* TrailSystem;

	UPROPERTY()
	UNiagaraComponent* TrailSystemComponent;

	UPROPERTY(EditDefaultsOnly)
	UStaticMeshComponent* ProjectileMesh;

	UPROPERTY(EditDefaultsOnly)
	float MinimumDamage = 10.0f;

	UPROPERTY(EditDefaultsOnly)
	float DamageInnerRadius = 200.0f;

	UPROPERTY(EditDefaultsOnly)
	float DamageOuterRadius = 500.0f;

	UPROPERTY(EditDefaultsOnly)
	float DamageFalloff = 1.0f;

	void SpawnTrailSystem();
	
	void DestroyTimerFinished();

	void StartDestroyTimer();

	void ExplodeDamage();

private:
	FTimerHandle DestroyTimer;

	UPROPERTY(EditAnywhere)
	float DetroyTime = 3.0f;
```



```cpp
#include "NiagaraFunctionLibrary.h"
#include "NiagaraComponent.h"

void AProjectile::SpawnTrailSystem()
{
    if (TrailSystem)
	{
		TrailSystemComponent = UNiagaraFunctionLibrary::SpawnSystemAttached(
			TrailSystem,
			GetRootComponent(),
			FName(),
			GetActorLocation(),
			GetActorRotation(),
			EAttachLocation::KeepWorldPosition,
			false
		);
	}
}

void AProjectile::StartDestroyTimer()
{
    GetWorldTimerManager().SetTimer(
		DestroyTimer,
		this,
		&ThisClass::DestroyTimerFinished,
		DetroyTime
	);
}

void AProjectile::DestroyTimerFinished()
{
    Destroy();
}

void AProjectile::ExplodeDamage()
{
	APawn* FiringPawn = GetInstigator();
	if (FiringPawn && HasAuthority())
	{
		AController* FiringController = FiringPawn->GetController();
		if (FiringController)
		{
			UGameplayStatics::ApplyRadialDamageWithFalloff(
				this,
				Damage,
				MinimumDamage,
				GetActorLocation(),
				DamageInnerRadius,
				DamageOuterRadius,
				DamageFalloff,
				UDamageType::StaticClass(),
				TArray<AActor*>(),
				this,
				FiringController
			);
		}
	}
}
```



### 创建`ProjectileGrenade`

继承自`Projectile`

```cpp
public:
	AProjectileGrenade();

	virtual void Destroyed() override;

protected:
	virtual void BeginPlay() override;

	UFUNCTION()
	void OnBounce(const FHitResult& ImpactResult, const FVector& ImpactVelocity);

private:
	UPROPERTY(EditAnywhere)
    USoundCue* BounceSound;
```



```cpp
#include "GameFramework/ProjectileMovementComponent.h"
#include "Sound/SoundCue.h"
#include "Kismet/GameplayStatics.h"


AProjectileGrenade::AProjectileGrenade()
{
    ProjectileMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("GrenadeMesh"));
	ProjectileMesh->SetupAttachment(RootComponent);
	ProjectileMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
    ProjectileMovementComponent = CreateDefaultSubobject<UProjectileMovementComponent>(TEXT("ProjectileMovementComponent"));
	ProjectileMovementComponent->bRotationFollowsVelocity = true;
	ProjectileMovementComponent->SetIsReplicated(true);
    ProjectileMovementComponent->bShouldBounce = true;
}

void AProjectileGrenade::BeginPlay()
{
    AActor::BeginPlay();
    
    StartDestroyTimer();
    SpawnTrailSystem();
    
    ProjectileMovementComponent->OnProjectileBounce.AddDynamic(this, &ThisClass::OnBounce);
}

void AProjectileGrenade::OnBounce(const FHitResult& ImpactResult, const FVector& ImpactVelocity)
{
    if(BounceSound)
    {
        UGameplayStatics::PlaySoundAtLocation(
        	this,
            BounceSound,
            GetActorLocation()
        );
    }
}

void AProjectileGrenade::Destroyed()
{
    ExplodeDamage();
    
    Super::Destroyed();
}
```



### 制作`NS_TrailSmoke_Grenade`

复制一份`NS_TrailSmoke`

取消勾选`NE_TrailFire`

`NE_TrailSmokeEmitter`里，`PARTICLE SPAWN`的`Uniform Sprite Size`改成(3.5,7)，`SCALE COLOR`的每个Curve的第二个坐标都改到(0.2,0.03)





### 制作`BP_ProjectileGrenade`

派生自`Projectilerenade`

`Mesh`选择`GrenadeLauncherA_Ammo`

`Box Extent`设置为(5,2,2)

`InitialSpeed`和`MaxSpeed`设置为3000

`Should Bounce`应该是勾选状态

`BounceSound`选择`GrenadeLauncher_Bounce_Cue`

`Damage`设置为120

`Impact Particle`设置为`P_Grenade_Explosion_01`

`Impact Sound`设置为`GrenadeLauncher_Explosion_Cue`

`TrailSystem`选择`NS_TrailSmoke_Grenade`

`DestroyTime`设置为1

`DamageInnerRadius`改成500

`DamageOuterRadius`改成850

### 修改`BP_GrenadeLauncher`里的`Projectile Class`为`BP_ProjectileGrenade`





# Reload Animations

## 为每种武器制作换弹动画

### 在`Reload Montage`里为每种武器添加Section和动画

最后在`Montage Section`里`Clear`掉默认产生的各个Section之间的过渡

#### RocketLauncher

新建`Section`命名为`RocketLauncher`

动画用`ReloadRocket`，这个动画的`Rate Scale`从1调整成0.2了

在动画的末尾复制一份`ReloadFinished`的Notify

在动画的开头`Add Notify`->`Play Sound`->`RocketLauncher_Raise_Cue`，后半段`Add Notify`->`Play Sound`->`RocketLauncher_Reload_Cue`

#### Pistol

新建`Section`命名为`Pistol`

动画用`Reload_Pistol`

在动画的末尾复制一份`ReloadFinished`的Notify

在动画的开头`Add Notify`->`Play Sound`->`Pistol_ReloadEject_Cue`，后半段`Add Notify`->`Play Sound`->`Pistol_Reload_Insert_Cue`

#### SubmachineGun

直接用Pistol的

#### Shotgun

新建`Section`命名为`Shotgun`

动画用`Reload_Shotgun_Hip`

在动画的末尾复制一份`ReloadFinished`的Notify

在动画的中间每次装进一颗子弹的时候`Add Notify`->`Play Sound`->`Shotgun_Reload_In_Cue`，末尾`Add Notify`->`Play Sound`->`Shotgun_Reload_Out_Cue`

#### SniperRifle

新建`Section`命名为`SniperRifle`

动画用`Reloading_SniperRifle`

在动画的末尾复制一份`ReloadFinished`的Notify

在动画的前半段`Add Notify`->`Play Sound`->`SniperRifle_Lower_Cue`，中间`Add Notify`->`Play Sound`->`SniperRifle_ReloadInsert_Cue`

#### GrenadeLauncher

新建`Section`命名为`GrenadeLauncher`

动画用`ReloadRifle`

在动画的末尾复制一份`ReloadFinished`的Notify

在动画的前半段`Add Notify`->`Play Sound`->`GrenadeLauncher_Raise_Cue`，后半段`Add Notify`->`Play Sound`->`GrenadeLauncher_Reload_Cue`





### 在`BlasterPlayer`里正确播放各类武器的换弹动画

```cpp
void ABlasterCharacter::PlayReloadMontage()
{
	if (!Combat || !Combat->EquippedWeapon)
	{
		return;
	}

	UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance();
	if (AnimInstance && ReloadMontage)
	{
		AnimInstance->Montage_Play(ReloadMontage);
		FName SectionName;
		switch (Combat->EquippedWeapon->GetWeaponType())
		{
		case EWeaponType::EWT_AssaultRifle:
		{
			SectionName = FName("Rifle");
			break;
		}
		case EWeaponType::EWT_RocketLauncher:
		{
			SectionName = FName("RocketLauncher");
			break;
		}
		case EWeaponType::EWT_Pistol:
		{
			SectionName = FName("Pistol");
			break;
		}
		case EWeaponType::EWT_SubmachineGun:
		{
			SectionName = FName("Pistol");
			break;
		}
		case EWeaponType::EWT_Shotgun:
		{
			SectionName = FName("Shotgun");
			break;
		}
		case EWeaponType::EWT_SniperRifle:
		{
			SectionName = FName("SniperRifle");
			break;
		}
		case EWeaponType::EWT_GrenadeLauncher:
		{
			SectionName = FName("GrenadeLauncher");
			break;
		}
		}

		AnimInstance->Montage_JumpToSection(SectionName);
	}
}
```







# Shotgun Reload

## 为霰弹枪换弹单独处理逻辑

从换弹开始到结束一共装弹四次，每次装弹都发一个`Shell`的`Notify`

每次`Notify`的时候Ammo+1，检查是否装满子弹，如果装满了就跳到End Section

当枪里有子弹时可以通过开火打断换弹动画

### 在`Reload Montage`里处理动画内容

在第四次`Shotgun_Reload_In_Cue`的`Notify` 后一点点的位置加一个新的`Section`命名为`ShotgunEnd`

在每次`Shotgun_Reload_In_Cue`的`Notify`时`Add Notify`->`New Notify`命名为`Shell`

在`Montage Section`里点击`Shotgun`右边的框选择`ShotgunEnd`，使得能自动过渡到下个Section



### 在`Weapon`里判断弹药是否装满、如果弹药已满则跳过装弹Section

```cpp
public:
	bool IsFull();
```



```cpp
#include "Blaster/BlasterComponents/CombatComponent.h"

bool AWeapon::IsFull()
{
    return Ammo == MagCapacity;
}

void AWeapon::OnRep_Ammo()
{
    BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast<ABlasterCharacter>(GetOwner()) : BlasterOwnerCharacter;
	if (BlasterOwnerCharacter && BlasterOwnerCharacter->GetCombat() && IsFull())
    {
        BlasterOwnerCharacter->GetCombat()->JumpToShotgunEnd();
    }
	SetHUDAmmo();
}
```



### 在`BlasterCharacter`里暴露出`Montage`

```cpp
public:
	FORCEINLINE UAnimMontage* GetReloadMontage() const { return ReloadMontage; }
```





### 在`CombatComponent`里编写霰弹枪换弹的特殊逻辑

```cpp
public:
	UFUNCTION(BlueprintCallable)
	void ShotgunShellReload();

	void UpdateShotgunAmmoValues();

	void JumpToShotgunEnd();
```



服务端直接调用函数`ShotgunShellReload`跳过动画，客户端走OnRep同步

```cpp
#include "Blaster/Character/BlasterAnimInstance.h"

void UCombatComponent::ShotgunShellReload()
{
    if(Character && Character->HasAuthority())
    {
        UpdateShotgunAmmoValues();
    }
}

void UCombatComponent::UpdateShotgunAmmoValues()
{
	if(!Character || !EquippedWeapon)
    {
        return;
    }
    
    if (CarriedAmmoMap.Contains(EquippedWeapon->GetWeaponType()))
	{
		CarriedAmmoMap[EquippedWeapon->GetWeaponType()] -= 1;
		CarriedAmmo = CarriedAmmoMap[EquippedWeapon->GetWeaponType()];
	}
    
    Controller = Controller == nullptr ? Cast<ABlasterPlayerController>(Character->Controller) : Controller;
	if (Controller)
	{
		Controller->SetHUDCarriedAmmo(CarriedAmmo);
	}
    
    EquippedWeapon->AddAmmo(1);
    bCanFire = true;
    if(EquippedWeapon->IsFull() || CarriedAmmo == 0)
    {
        JumpToShotgunEnd();
    }
}

void UCombatComponent::JumpToShotgunEnd()
{
    UAnimInstance* AnimInstance = Character->GetMesh()->GetAnimInstance();
    if (AnimInstance && Character->GetReloadMontage())
    {
        AnimInstance->Montage_JumpToSection(FName("ShotgunEnd"));
    }
}

void UCombatComponent::OnRep_CarriedAmmo()
{
	Controller = Controller == nullptr ? Cast<ABlasterPlayerController>(Character->Controller) : Controller;
	if (Controller)
	{
		Controller->SetHUDCarriedAmmo(CarriedAmmo);
	}
    
    bool bJumpToShotgunEnd = CombatState == ECombatState::ECS_Reloading &&
        EquippedWeapon &&
        EquippedWeapon->GetWeaponType() == EWeaponType::EWT_Shotgun &&
        CarriedAmmo == 0;
    if(bJumpToShotgunEnd)
    {
        JumpToShotgunEnd();
    }
}

bool UCombatComponent::CanFire()
{
	if (!EquippedWeapon)
	{
		return false;
	}
    
    if(!EquippedWeapon->IsEmpty() && bCanFire && CombatState == ECombatState::ECS_Reloading && EquippedWeapon->GetWeaponType() == EWeaponType::EWT_Shotgun)
    {
        return true;
    }

	return !EquippedWeapon->IsEmpty() && bCanFire && CombatState == ECombatState::ECS_Unoccupied;
}

void UCombatComponent::MulticastFire_Implementation(const FVector_NetQuantize& TraceHitTarget)
{
	if (!EquippedWeapon)
	{
		return;
	}

    if (Character && CombatState == ECombatState::ECS_Reloading && EquippedWeapon->GetWeaponType() == EWeaponType::EWT_Shotgun)
    {
        Character->PlayFireMontage(bIsAiming);
		EquippedWeapon->Fire(TraceHitTarget);
        CombatState = ECombatState::ECS_Unoccupied;
        return;
    }
    
	if (Character && CombatState == ECombatState::ECS_Unoccupied)
	{
		Character->PlayFireMontage(bIsAiming);
		EquippedWeapon->Fire(TraceHitTarget);
	}
}
```



### 在`BP_BlasterAnim`动画蓝图的`Event Graph`调用`ShotgunShellReload`

`Event AnimNotify_Shell`->`Blaster Character` `Is Valid`->`Combat` `Is Valid`->`ShotgunShellReload` 

![1703063858762](pics\1703063858762.png)






# Weapon Outline Effect

## 让武器能高亮

不同Mesh的`CustomDepth Stencil Value`用后处理材料的模板值来高亮显示不同颜色



### 在`BlasterMap`添加`PP_Highlight`后处理材料

在`PostProcessVolume`的`Infinite Extent`保持为勾选状态，`Post Process Materials`的Array添加`Asset Reference`选择`PP_Highlight`



### 在`WeaponType`编码不同色彩的宏定义

```cpp
#define CUSTOM_DEPTH_PURPLE 250
#define CUSTOM_DEPTH_BLUE 251
#define CUSTOM_DEPTH_TAN 252
```



### 在`Weapon`里添加是否启用自定义深度渲染`RenderCustomDepth`

```cpp
public:
	void EnableCustomDepth(bool bEnable);
```



```cpp
void AWeapon::EnableCustomDepth(bool bEnable)
{
    if(WeaponMesh)
    {
        WeaponMesh->SetRenderCustomDepth(bEnable);
    }
}

AWeapon::AWeapon()
{
    // ...
    WeaponMesh->SetCustomDepthStencilValue(CUSTOM_DEPTH_BLUE);
    WeaponMesh->MarkRenderStateDirty();
    EnableCustomDepth(true);
}

void AWeapon::SetWeaponState(EWeaponState State)
{
    // ...
    case EWeaponState::EWS_Equipped:
    {
        // ...
        EnableCustomDepth(false);
    }
    case EWeaponState::EWS_Dropped:
    {
        // ...
        WeaponMesh->SetCustomDepthStencilValue(CUSTOM_DEPTH_BLUE);
    	WeaponMesh->MarkRenderStateDirty();
        EnableCustomDepth(true);
    }
}

void AWeapon::OnRep_WeaponState()
{
    // ...
    case EWeaponState::EWS_Equipped:
    {
        // ...
        EnableCustomDepth(false);
    }
    case EWeaponState::EWS_Dropped:
    {
        // ...
        WeaponMesh->SetCustomDepthStencilValue(CUSTOM_DEPTH_BLUE);
    	WeaponMesh->MarkRenderStateDirty();
        EnableCustomDepth(true);
    }
}
```



### 检查武器蓝图是否覆盖了cpp的内容

`WeaponMesh`->`Rendering`，`Render CustomDepth Pass`勾选打开，`CustomDepthStencil Value`改成想要的颜色比如251



### 更新`Project Settings`里的`Rendering`

`Custom Depth-Stencil Pass`改成`Enable with Stencil`才能用自定义深度









# Grenade Throw Montage

## 投掷手榴弹

### 制作投掷手榴弹的动画

从`Toss_Grenade_Retargeted`切一下，只保留中间的部分重命名为`GrenadeToss`

`Rate Scale`改成1.5让视觉效果好一些



### 创建投掷手榴弹`ThrowGrenade`的Montage

Slot用`Weapon Slot`

在动画的末尾加一个Notify命名为`FinishGrenadeThrow`



### 在`CombatState`里添加投掷手榴弹的战斗状态枚举

```cpp
UENUM(BlueprintType)
enum class ECombatState : uint8
{
	ECS_Unoccupied UMETA(DisplayName = "Unoccupied"),
	ECS_Reloading UMETA(DisplayName = "Reloading"),
    ECS_ThrowingGrenade UMETA(DisplayName = "Throwing Grenade"),
	ECS_MAX UMETA(DisplayName = "DefaultMAX")
};
```



### 在`CombatComponent`里处理投掷手榴弹的逻辑

```cpp
public:
	UFUNCTION(BlueprintCallable)
    void ThrowGrenadeFinished();

protected:
	void ThorwGrenade();

	UFUNCTION(Server, Reliable)
    void ServerThrowGrenade();
```



```cpp
void UCombatComponent::ThrowGrenadeFinished()
{
    CombatState = ECombatState::ECS_Unoccupied;
}

void UCombatComponent::ThorwGrenade()
{
    if(CombatState != ECombatState::ECS_Unoccupied)
    {
        return;
    }
    
    CombatState = ECombatState::ECS_ThrowingGrenade;
    if(Character)
    {
        Character->PlayThrowGrenadeMontage();
    }
    
    if(Character && !Character->HasAuthority())
    {
        ServerThrowGrenade();
    }
}

void UCombatComponent::ServerThrowGrenade_Implementation()
{
    CombatState = ECombatState::ECS_ThrowingGrenade;
    if(Character)
    {
        Character->PlayThrowGrenadeMontage();
    }
}

void UCombatComponent::OnRep_CombatState()
{
    // ...
    case ECombatState::ECS_ThrowingGrenade:
	{
        if(Character && !Character->IsLocallyControlled())
        {
            Character->PlayThrowGrenadeMontage();
        }
		break;
	}
}

void UCombatComponent::Reload()
{
	if (CarriedAmmo > 0 && CombatState == ECombatState::ECS_Unoccupied)
	{
		ServerReload();
	}
}

void UCombatComponent::EquipWeapon(AWeapon* WeaponToEquip)
{
    if(CombatState != ECombatState::ECS_Unoccupied)
    {
        return;
    }
    
    // ...
}
```



### 在`BlasterCharacter`里处理Montage的播放和投掷手榴弹的按键映射

添加个`ThrowGrenade`按键映射键盘的`Key G`



```cpp
public:
	void PlayThrowGrenadeMontage();

protected:
	void GrenadeButtonPressed();

private:
	UPROPERTY(EditAnywhere, Category = Combat)
	UAnimMontage* ThrowGrenadeMontage;
```



```cpp

void ABlasterCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
    // ...
    PlayerInputComponent->BindAction("ThrowGrenade", IE_Pressed, this, &ThisClass::GrenadeButtonPressed);
}

void ABlasterCharacter::GrenadeButtonPressed()
{
    if(Combat)
    {
        Combat->ThorwGrenade();
    }
}

void ABlasterCharacter::PlayThrowGrenadeMontage()
{
    UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance();
	if (AnimInstance && ThrowGrenadeMontage)
	{
		AnimInstance->Montage_Play(ThrowGrenadeMontage);
	}
}
```





### 在`BlasterAnimInstance`里处理投掷手榴弹时不再单独处理右手动画

```cpp
void UBlasterAnimInstance::NativeUpdateAnimation(float DeltaTime)
{
    // ...
    bUseFABRIK = BlasterCharacter->GetCombatState() == ECombatState::ECS_Unoccupied;
	bUseAimOffsets = BlasterCharacter->GetCombatState() == ECombatState::ECS_Unoccupied && !BlasterCharacter->GetDisableGameplay();
	bTransformRightHand = BlasterCharacter->GetCombatState() == ECombatState::ECS_Unoccupied && !BlasterCharacter->GetDisableGameplay();
}
```



### 在`BP_BlasterAnim`里处理投掷手榴弹的动画

`Event AnimNotify_FinishGrenadeThrow`->拿到BlasterCharacter的Combat->`Throw Grenade Finished`



![1703235264594](pics\1703235264594.png)







# Weapon Attachment while Throwing Grenades

## 投掷手榴弹时把武器固定到左手，投掷完了再固定回右手

### 在`SK_EpicCharacter_Skeleton`里添加左手Socket

`hand_l`下添加socket命名为`LeftHandSocket`，在`GrenadeToss`动画里预览一下socket的朝向并修改让持枪动作看起来好一些，比如左手的位置和持枪时的位置一致

`hand_l`下再添加socket命名为`PistolSocket`，用来处理手枪和冲锋枪的绑定位置，在`GrenadeToss`动画里预览一下socket的朝向并修改让持枪动作看起来好一些，比如左手的位置和持枪时的位置一致



### 在`CombatComponent`里处理

顺便重构一下`EquipWeapon`，把代码提到单独的函数里



```cpp
protected:
	void DropEquippedWeapon();
	void AttachActorToRightHand(AActor* ActorToAttach);
	void UpdateCarriedAmmo();
	void AttachActorToLeftHand(AActor* ActorToAttach);
```



```cpp
void UCombatComponent::DropEquippedWeapon()
{
    if (EquippedWeapon)
	{
		EquippedWeapon->Dropped();
	}
}

void UCombatComponent::AttachActorToRightHand(AActor* ActorToAttach)
{
    if(!Character || !Character->GetMesh() || !ActorToAttach)
    {
        return;
    }
    
    const USkeletalMeshSocket* HandSocket = Character->GetMesh()->GetSocketByName(FName("RightHandSocket"));
	if (HandSocket)
	{
		HandSocket->AttachActor(ActorToAttach, Character->GetMesh());
	}
}

void UCombatComponent::UpdateCarriedAmmo()
{
    if(!EquippedWeapon)
    {
        return;
    }
    
    if (CarriedAmmoMap.Contains(EquippedWeapon->GetWeaponType()))
	{
		CarriedAmmo = CarriedAmmoMap[EquippedWeapon->GetWeaponType()];
	}
    
    Controller = Controller == nullptr ? Cast<ABlasterPlayerController>(Character->Controller) : Controller;
	if (Controller)
	{
		Controller->SetHUDCarriedAmmo(CarriedAmmo);
	}
}

void UCombatComponent::EquipWeapon(AWeapon* WeaponToEquip)
{
	if (!Character || !WeaponToEquip)
	{
		return;
	}
	
	if (CombatState != ECombatState::ECS_Unoccupied)
	{
		return;
	}

	DropEquippedWeapon();

	EquippedWeapon = WeaponToEquip;
	EquippedWeapon->SetWeaponState(EWeaponState::EWS_Equipped);
	EquippedWeapon->SetOwner(Character);
	EquippedWeapon->SetHUDAmmo();

	UpdateCarriedAmmo();

	AttachActorToRightHand(EquippedWeapon);

	Character->bUseControllerRotationYaw = true;
	Character->GetCharacterMovement()->bOrientRotationToMovement = false;

	PlayEquipWeaponSound();
	AutoReload();
}

void UCombatComponent::OnRep_EquippedWeapon()
{
	if (Character && EquippedWeapon)
	{
		EquippedWeapon->SetWeaponState(EWeaponState::EWS_Equipped);
		AttachActorToRightHand(EquippedWeapon);
		Character->bUseControllerRotationYaw = true;
		Character->GetCharacterMovement()->bOrientRotationToMovement = false;

		PlayEquipWeaponSound();
	}

	if (Character)
	{
		Character->UpdateHUDWeaponAmmo();
		Character->UpdateHUDCarriedAmmo();
	}
}

void UCombatComponent::AttachActorToLeftHand(AActor* ActorToAttach)
{
    if(!Character || !Character->GetMesh() || !ActorToAttach || !EquippedWeapon)
    {
        return;
    }
    
    bool bUsePistolSocket = EquippedWeapon->GetWeaponType() == EWeaponType::EWT_Pistol || EquippedWeapon->GetWeaponType() == EWeaponType::EWT_SubmachineGun;
    FName SocketName = bUsePistolSocket ? FName("PistolSocket") : FName("LeftHandSocket");
    const USkeletalMeshSocket* HandSocket = Character->GetMesh()->GetSocketByName(SocketName);
	if (HandSocket)
	{
		HandSocket->AttachActor(ActorToAttach, Character->GetMesh());
	}
}

void UCombatComponent::OnRep_CombatState()
{
    // ...
	case ECombatState::ECS_ThrowingGrenade:
	{
		if (Character && !Character->IsLocallyControlled())
		{
			Character->PlayThrowGrenadeMontage();
            AttachActorToLeftHand(EquippedWeapon);
		}
		break;
	}
	}
}

void UCombatComponent::ThrowGrenadeFinished()
{
	CombatState = ECombatState::ECS_Unoccupied;
    AttachActorToRightHand(EquippedWeapon);
}

void UCombatComponent::ThorwGrenade()
{
	if (CombatState != ECombatState::ECS_Unoccupied)
	{
		return;
	}

	CombatState = ECombatState::ECS_ThrowingGrenade;
	if (Character)
	{
		Character->PlayThrowGrenadeMontage();
        AttachActorToLeftHand(EquippedWeapon);
	}

	if (Character && !Character->HasAuthority())
	{
		ServerThrowGrenade();
	}
}

void UCombatComponent::ServerThrowGrenade_Implementation()
{
	CombatState = ECombatState::ECS_ThrowingGrenade;
	if (Character)
	{
		Character->PlayThrowGrenadeMontage();
        AttachActorToLeftHand(EquippedWeapon);
	}
}
```





# Grenade Assets

## 制作手榴弹

### 找个手榴弹的 Asset

epic商店有个`Paragon:Wraith`



### 在`SK_EpicCharacter_Skeleton`里添加手榴弹绑定的`GrenadeSocket`

`hand_r`加一个socket命名为`GrenadeSocket`，在`GrenadeToss`里预览并调整socket的位置





### 在`BlasterCharacter`里处理手榴弹



```cpp
private:
	UPROPERTY(EditAnywhere)
	UStaticMeshComponent* AttachedGrenade;
```



```cpp
ABlasterCharacter::ABlasterCharacter()
{
	// ...
    AttachedGrenade = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("AttachedGrenade"));
    AttachedGrenade->SetupAttachment(GetMesh(), FName("GrenadeSocket"));
    AttachedGrenade->SetCollisionEnabled(ECollisionEnabled::NoCollision);
    
}
```



### 在`BP_Blaster`里配置手榴弹

用`SM_Wraith_Drone`作为`StaticMesh`

`Scale`改成(2,2,2)







# Showing the Attached Grenade

## 在合适的时机显示和隐藏手中的手榴弹Mesh



### 在`GrenadeToss`里添加隐藏手榴弹的AnimNotify

在手榴弹出手的时候新增一个`GrenadeLaunch`



### 在`BlasterCharacter`里处理默认隐藏

```cpp
public:
	FORCEINLINE UStaticMeshComponent* GetAttachedGrenade() const { return AttachedGrenade; }
```



```cpp
void ABlasterCharacter::BeginPlay()
{
    // ...
    if(AttachedGrenade)
    {
        AttachedGrenade->SetVisibility(false);
    }
}
```



### 在`CombatComponent`里处理投掷时的显示以及动画蓝图调用的函数

```cpp
public:
	UFUNCTION(BlueprintCallable)
    void LaunchGrenade();

private:
	void ShowAttachedGrenade(bool bShowGrenade);
```



```cpp
void UCombatComponent::ShowAttachedGrenade(bool bShowGrenade)
{
    if(Character && Character->GetAttachedGrenade())
    {
        Character->GetAttachedGrenade()->SetVisibility(bShowGrenade);
    }
}

void UCombatComponent::LaunchGrenade()
{
    ShowAttachedGrenade(false);
}

void UCombatComponent::ThorwGrenade()
{
    // ...
    if (Character)
    {
        // ...
        ShowAttachedGrenade(true);
    }
}

void UCombatComponent::ServerThrowGrenade_Implementation()
{
	// ...
    if (Character)
    {
        // ...
        ShowAttachedGrenade(true);
    }
}

void UCombatComponent::OnRep_CombatState()
{
	// ...
    case ECombatState::ECS_ThrowingGrenade:
	{
		if (Character && !Character->IsLocallyControlled())
		{
			// ...
            ShowAttachedGrenade(true);
		}
		break;
	}
}
```





### 在`BP_BlasterAnim`里处理Notify

`Event AnimNotify_GrenadeLaunch`->判断`Character`和`Character->Combat`的`IsValid`->调用`Combat`的`LaunchGrenade`



![1703478251481](pics\1703478251481.png)







# Spawning Grenades

## 制作手榴弹

### 用`BP_ProjectileGrenade`为基底修改一下Mesh作为`BP_ThrowGrenade`

`Static Mesh`取消掉选项变为`None`

`Box Extent`改成(12,12,12)

在蓝图里直接加一个`ParticleSystem`的`Component`命名为`GrenadeParticleSystem`，`Template`用`P_Wraith_Drone_Attached_TeamColored`，并旋转z轴90度

`Destroy Time`改成2秒



### 在`CombatComponent`里处理Spawn Grenade

```cpp
protected:
	UPROPERTY(EditAnywhere)
	TSubclassOf<AProjectile> GrenadeClass;

private:
	void SpawnThrowGrenadeProjectile();
```



顺便修一下没有武器的时候投掷手榴弹会导致手里的Mesh不消失的问题

```cpp
#include "Blaster/Weapon/Projectile.h"

void UCombatComponent::LaunchGrenade()
{
    // ...
    SpawnThrowGrenadeProjectile();
}

void UCombatComponent::SpawnThrowGrenadeProjectile()
{
	if (Character && Character->HasAuthority() && GrenadeClass && Character->GetAttachedGrenade())
	{
		const FVector StartingLocation = Character->GetAttachedGrenade()->GetComponentLocation();
		FVector ToTarget = HitTarget - StartingLocation;
		FActorSpawnParameters SpawnParams;
		SpawnParams.Owner = Character;
		SpawnParams.Instigator = Character;

		UWorld* World = GetWorld();
		if (World)
		{
			World->SpawnActor<AProjectile>(
				GrenadeClass,
				StartingLocation,
				ToTarget.Rotation(),
				SpawnParams
				);
		}
	}
}

void UCombatComponent::ThorwGrenade()
{
    // ...
    if(!EquippedWeapon)
    {
        return;
    }
}
```







# Grenades in Multiplayer

## 客户端也能正确方向投掷手榴弹

### 在`CombatComponent`里加个ServerRPC传递投掷方向

```cpp
public:
	UFUNCTION(Server, Reliable)
	void ServerLaunchGrenade(const FVector_NetQuantize& Target);
```



```cpp
void UCombatComponent::LaunchGrenade()
{
    // ...
    if(Character && Character->IsLocallyControlled())
    {
        ServerLaunchGrenade(HitTarget);
    }
}

void UCombatComponent::ServerLaunchGrenade_Implementation(const FVector_NetQuantize& Target)
{
    if (Character && GrenadeClass && Character->GetAttachedGrenade())
	{
		const FVector StartingLocation = Character->GetAttachedGrenade()->GetComponentLocation();
		FVector ToTarget = Target - StartingLocation;
		FActorSpawnParameters SpawnParams;
		SpawnParams.Owner = Character;
		SpawnParams.Instigator = Character;

		UWorld* World = GetWorld();
		if (World)
		{
			World->SpawnActor<AProjectile>(
				GrenadeClass,
				StartingLocation,
				ToTarget.Rotation(),
				SpawnParams
				);
		}
	}
}
```





# Grenades in the HUD

## 在HUD上显示手榴弹数量

### 在`WBP_CharacterOverlay`添加手榴弹控件

拖一个`TextBlock` 命名为 `GrenadesText`放在弹药的下面

拖一个`Image`命名为 `GrenadesImage`，`Image`用`GrenadeTextureOutlined12`



### 在`CharacterOverlay`添加手榴弹文本变量

```cpp
priavte:
	UPROPERTY(meta = (BindWidget))
	UTextBlock* GrenadesText;
```



### 在`BlasterPlayerController`处理修改倒计时文本

```cpp
public:
	void SetHUDGrenades(int32 Grenades);
```



```cpp
void ABlasterPlayerController::PollInit()
{
	// ...
	if (CharacterOverlay)
	{
		// ...
        ABlasterCharacter* BlasterCharacter = Cast<ABlasterCharacter>(GetPawn());
        if(BlasterCharacter && BlasterCharacter->GetCombat())
        {
            SetHUDGrenades(BlasterCharacter->GetCombat()->GetGrenades());
        }
        
	}

}

void ABlasterPlayerController::SetHUDGrenades(int32 Grenades)
{
    BlasterHUD = BlasterHUD == nullptr ? Cast<ABlasterHUD>(GetHUD()) : BlasterHUD;
	bool bHUDValid = BlasterHUD &&
		BlasterHUD->CharacterOverlay &&
		BlasterHUD->CharacterOverlay->GrenadesText;

	if (bHUDValid)
	{
		FString GrenadesText = FString::Printf(TEXT("%d"), Grenades);
		BlasterHUD->CharacterOverlay->GrenadesText->SetText(FText::FromString(GrenadesText));
	}
}
```



### 在`CombatComponent`处理手榴弹数量的变化

```cpp
public:
	FORCEINLINE int32 GetGrenades() const { return Grenades; }

private:
	UPROPERTY(ReplicatedUsing = OnRep_Grenades)
	int32 Grenades = 0;
	
	UPROPERTY(EditAnywhere)
	int32 MaxGrenades = 4;

	UFUNCTION()
    void OnRep_Grenades();

	void UpdateHUDGrenades();
```



```cpp
void UCombatComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	// ...
	DOREPLIFETIME(UCombatComponent, Grenades);
}

void UCombatComponent::ThorwGrenade()
{
    if(Grenades == 0)
    {
        return;
    }
    
    // ...
    
    if(Character && Character->HasAuthority())
    {
        Grenades = FMath::Clamp(Grenades - 1, 0, MaxGrenades);
    	UpdateHUDGrenades();
    }
}

void UCombatComponent::ServerThrowGrenade_Implementation()
{
    if(Grenades == 0)
    {
        return;
    }
    // ...
    
    Grenades = FMath::Clamp(Grenades - 1, 0, MaxGrenades);
    UpdateHUDGrenades();
}

void UCombatComponent::UpdateHUDGrenades()
{
    if(!Character)
    {
        return;
    }
    
    Controller = Controller == nullptr ? Cast<ABlasterPlayerController>(Character->Controller) : Controller;
    
    if(Controller)
    {
        Controller->SetHUDGrenades(Grenades);
    }
}

void UCombatComponent::OnRep_Grenades()
{
    UpdateHUDGrenades();
}
```





### 投掷手榴弹时加个音效

找个sound cue，`Attenuation Settings`用`Footsteps_att`，`Volume Multiplier`改成1.25

然后在`ThrowGrenade`的`AnimMontage`里在脱手的时候`Add Sound`





## 修一下对被淘汰玩家造成伤害算淘汰数+1的问题

### 在`BlasterCharacter`里校验一下

```cpp
void ABlasterCharacter::ReceiveDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatorController, AActor* DamageCauser)
{
    if(bElimmed)
    {
        return;
    }
    
    // ...
}
```



## 手榴弹扔的时候会和自己的头发生碰撞

spawn的起始位置往前一点



```cpp
void UCombatComponent::ServerLaunchGrenade_Implementation(const FVector_NetQuantize& Target)
{
	if (Character && GrenadeClass && Character->GetAttachedGrenade())
	{
		const FVector StartingLocation = Character->GetAttachedGrenade()->GetComponentLocation();
		FVector ToTarget = Target - StartingLocation;
		FActorSpawnParameters SpawnParams;
		SpawnParams.Owner = Character;
		SpawnParams.Instigator = Character;
		FVector SpawnLocation = StartingLocation + ToTarget.Normalize() * 20;

		UWorld* World = GetWorld();
		if (World)
		{
			World->SpawnActor<AProjectile>(
				GrenadeClass,
				SpawnLocation,
				ToTarget.Rotation(),
				SpawnParams
			);

			// DrawDebugLine(World, SpawnLocation, Target, FColor::Red, true);
		}
	}
}
```







